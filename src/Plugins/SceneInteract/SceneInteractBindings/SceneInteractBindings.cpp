// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "SceneInteract.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif

#include "IRenderer.h"


using namespace Tundra;
using namespace std;

namespace JSBindings
{

static const char* RayQueryResult_ID = "RayQueryResult";
static const char* float3_ID = "float3";

static duk_ret_t RayQueryResult_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<RayQueryResult>(ctx, RayQueryResult_ID);
    return 0;
}

static duk_ret_t float3_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<float3>(ctx, float3_ID);
    return 0;
}


static const char* SceneInteract_ID = "SceneInteract";

const char* SignalWrapper_SceneInteract_EntityMouseMove_ID = "SignalWrapper_SceneInteract_EntityMouseMove";

class SignalWrapper_SceneInteract_EntityMouseMove
{
public:
    SignalWrapper_SceneInteract_EntityMouseMove(Object* owner, Signal3< Entity *, int, RayQueryResult * >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal3< Entity *, int, RayQueryResult * >* signal_;
};

class SignalReceiver_SceneInteract_EntityMouseMove : public SignalReceiver
{
public:
    void OnSignal(Entity * param0, int param1, RayQueryResult * param2)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        duk_push_number(ctx, param1);
        duk_put_prop_index(ctx, -2, 1);
        PushValueObjectCopy<RayQueryResult>(ctx, *param2, RayQueryResult_ID, RayQueryResult_Finalizer);
        duk_put_prop_index(ctx, -2, 2);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseMove_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_SceneInteract_EntityMouseMove>(ctx, SignalWrapper_SceneInteract_EntityMouseMove_ID);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseMove_Connect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityMouseMove* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityMouseMove>(ctx, SignalWrapper_SceneInteract_EntityMouseMove_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_SceneInteract_EntityMouseMove* receiver = new SignalReceiver_SceneInteract_EntityMouseMove();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_SceneInteract_EntityMouseMove::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseMove_Disconnect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityMouseMove* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityMouseMove>(ctx, SignalWrapper_SceneInteract_EntityMouseMove_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseMove_Emit(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityMouseMove* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityMouseMove>(ctx, SignalWrapper_SceneInteract_EntityMouseMove_ID);
    if (!wrapper->owner_) return 0;
    Entity* param0 = GetWeakObject<Entity>(ctx, 0);
    int param1 = (int)duk_require_number(ctx, 1);
    RayQueryResult* param2 = GetValueObject<RayQueryResult>(ctx, 2, RayQueryResult_ID);
    wrapper->signal_->Emit(param0, param1, param2);
    return 0;
}

static duk_ret_t SceneInteract_Get_EntityMouseMove(duk_context* ctx)
{
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    SignalWrapper_SceneInteract_EntityMouseMove* wrapper = new SignalWrapper_SceneInteract_EntityMouseMove(thisObj, &thisObj->EntityMouseMove);
    PushValueObject(ctx, wrapper, SignalWrapper_SceneInteract_EntityMouseMove_ID, SignalWrapper_SceneInteract_EntityMouseMove_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityMouseMove_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityMouseMove_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityMouseMove_Emit, 3);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_SceneInteract_EntityMouseScroll_ID = "SignalWrapper_SceneInteract_EntityMouseScroll";

class SignalWrapper_SceneInteract_EntityMouseScroll
{
public:
    SignalWrapper_SceneInteract_EntityMouseScroll(Object* owner, Signal3< Entity *, int, RayQueryResult * >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal3< Entity *, int, RayQueryResult * >* signal_;
};

class SignalReceiver_SceneInteract_EntityMouseScroll : public SignalReceiver
{
public:
    void OnSignal(Entity * param0, int param1, RayQueryResult * param2)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        duk_push_number(ctx, param1);
        duk_put_prop_index(ctx, -2, 1);
        PushValueObjectCopy<RayQueryResult>(ctx, *param2, RayQueryResult_ID, RayQueryResult_Finalizer);
        duk_put_prop_index(ctx, -2, 2);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseScroll_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_SceneInteract_EntityMouseScroll>(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_ID);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseScroll_Connect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityMouseScroll* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityMouseScroll>(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_SceneInteract_EntityMouseScroll* receiver = new SignalReceiver_SceneInteract_EntityMouseScroll();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_SceneInteract_EntityMouseScroll::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseScroll_Disconnect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityMouseScroll* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityMouseScroll>(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityMouseScroll_Emit(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityMouseScroll* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityMouseScroll>(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_ID);
    if (!wrapper->owner_) return 0;
    Entity* param0 = GetWeakObject<Entity>(ctx, 0);
    int param1 = (int)duk_require_number(ctx, 1);
    RayQueryResult* param2 = GetValueObject<RayQueryResult>(ctx, 2, RayQueryResult_ID);
    wrapper->signal_->Emit(param0, param1, param2);
    return 0;
}

static duk_ret_t SceneInteract_Get_EntityMouseScroll(duk_context* ctx)
{
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    SignalWrapper_SceneInteract_EntityMouseScroll* wrapper = new SignalWrapper_SceneInteract_EntityMouseScroll(thisObj, &thisObj->EntityMouseScroll);
    PushValueObject(ctx, wrapper, SignalWrapper_SceneInteract_EntityMouseScroll_ID, SignalWrapper_SceneInteract_EntityMouseScroll_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityMouseScroll_Emit, 3);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_SceneInteract_EntityClicked_ID = "SignalWrapper_SceneInteract_EntityClicked";

class SignalWrapper_SceneInteract_EntityClicked
{
public:
    SignalWrapper_SceneInteract_EntityClicked(Object* owner, Signal3< Entity *, int, RayQueryResult * >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal3< Entity *, int, RayQueryResult * >* signal_;
};

class SignalReceiver_SceneInteract_EntityClicked : public SignalReceiver
{
public:
    void OnSignal(Entity * param0, int param1, RayQueryResult * param2)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        duk_push_number(ctx, param1);
        duk_put_prop_index(ctx, -2, 1);
        PushValueObjectCopy<RayQueryResult>(ctx, *param2, RayQueryResult_ID, RayQueryResult_Finalizer);
        duk_put_prop_index(ctx, -2, 2);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_SceneInteract_EntityClicked_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_SceneInteract_EntityClicked>(ctx, SignalWrapper_SceneInteract_EntityClicked_ID);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityClicked_Connect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityClicked* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityClicked>(ctx, SignalWrapper_SceneInteract_EntityClicked_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_SceneInteract_EntityClicked* receiver = new SignalReceiver_SceneInteract_EntityClicked();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_SceneInteract_EntityClicked::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityClicked_Disconnect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityClicked* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityClicked>(ctx, SignalWrapper_SceneInteract_EntityClicked_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityClicked_Emit(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityClicked* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityClicked>(ctx, SignalWrapper_SceneInteract_EntityClicked_ID);
    if (!wrapper->owner_) return 0;
    Entity* param0 = GetWeakObject<Entity>(ctx, 0);
    int param1 = (int)duk_require_number(ctx, 1);
    RayQueryResult* param2 = GetValueObject<RayQueryResult>(ctx, 2, RayQueryResult_ID);
    wrapper->signal_->Emit(param0, param1, param2);
    return 0;
}

static duk_ret_t SceneInteract_Get_EntityClicked(duk_context* ctx)
{
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    SignalWrapper_SceneInteract_EntityClicked* wrapper = new SignalWrapper_SceneInteract_EntityClicked(thisObj, &thisObj->EntityClicked);
    PushValueObject(ctx, wrapper, SignalWrapper_SceneInteract_EntityClicked_ID, SignalWrapper_SceneInteract_EntityClicked_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityClicked_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityClicked_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityClicked_Emit, 3);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_SceneInteract_EntityClickReleased_ID = "SignalWrapper_SceneInteract_EntityClickReleased";

class SignalWrapper_SceneInteract_EntityClickReleased
{
public:
    SignalWrapper_SceneInteract_EntityClickReleased(Object* owner, Signal3< Entity *, int, RayQueryResult * >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal3< Entity *, int, RayQueryResult * >* signal_;
};

class SignalReceiver_SceneInteract_EntityClickReleased : public SignalReceiver
{
public:
    void OnSignal(Entity * param0, int param1, RayQueryResult * param2)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        duk_push_number(ctx, param1);
        duk_put_prop_index(ctx, -2, 1);
        PushValueObjectCopy<RayQueryResult>(ctx, *param2, RayQueryResult_ID, RayQueryResult_Finalizer);
        duk_put_prop_index(ctx, -2, 2);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_SceneInteract_EntityClickReleased_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_SceneInteract_EntityClickReleased>(ctx, SignalWrapper_SceneInteract_EntityClickReleased_ID);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityClickReleased_Connect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityClickReleased* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityClickReleased>(ctx, SignalWrapper_SceneInteract_EntityClickReleased_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_SceneInteract_EntityClickReleased* receiver = new SignalReceiver_SceneInteract_EntityClickReleased();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_SceneInteract_EntityClickReleased::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityClickReleased_Disconnect(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityClickReleased* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityClickReleased>(ctx, SignalWrapper_SceneInteract_EntityClickReleased_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_SceneInteract_EntityClickReleased_Emit(duk_context* ctx)
{
    SignalWrapper_SceneInteract_EntityClickReleased* wrapper = GetThisValueObject<SignalWrapper_SceneInteract_EntityClickReleased>(ctx, SignalWrapper_SceneInteract_EntityClickReleased_ID);
    if (!wrapper->owner_) return 0;
    Entity* param0 = GetWeakObject<Entity>(ctx, 0);
    int param1 = (int)duk_require_number(ctx, 1);
    RayQueryResult* param2 = GetValueObject<RayQueryResult>(ctx, 2, RayQueryResult_ID);
    wrapper->signal_->Emit(param0, param1, param2);
    return 0;
}

static duk_ret_t SceneInteract_Get_EntityClickReleased(duk_context* ctx)
{
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    SignalWrapper_SceneInteract_EntityClickReleased* wrapper = new SignalWrapper_SceneInteract_EntityClickReleased(thisObj, &thisObj->EntityClickReleased);
    PushValueObject(ctx, wrapper, SignalWrapper_SceneInteract_EntityClickReleased_ID, SignalWrapper_SceneInteract_EntityClickReleased_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityClickReleased_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityClickReleased_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_SceneInteract_EntityClickReleased_Emit, 3);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

static duk_ret_t SceneInteract_CurrentMouseRaycastResult(duk_context* ctx)
{
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    RayQueryResult * ret = thisObj->CurrentMouseRaycastResult();
    PushValueObjectCopy<RayQueryResult>(ctx, *ret, RayQueryResult_ID, RayQueryResult_Finalizer);
    return 1;
}

static duk_ret_t SceneInteract_RaycastClosestIntersect_float3_float3_unsigned_float(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    float3& from = *GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3& to = *GetCheckedValueObject<float3>(ctx, 1, float3_ID);
    unsigned layerMask = numArgs > 2 ? (unsigned)duk_require_number(ctx, 2) : 0xffffffff;
    float maxDistance = numArgs > 3 ? (float)duk_require_number(ctx, 3) : 1000.0f;
    float3 ret = thisObj->RaycastClosestIntersect(from, to, layerMask, maxDistance);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t SceneInteract_RaycastClosestIntersect_float3_float3Vector_unsigned_float(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    float3& from = *GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    Vector<float3> to = GetValueObjectVector<float3>(ctx, 1, float3_ID);
    unsigned layerMask = numArgs > 2 ? (unsigned)duk_require_number(ctx, 2) : 0xffffffff;
    float maxDistance = numArgs > 3 ? (float)duk_require_number(ctx, 3) : 1000.0f;
    float3 ret = thisObj->RaycastClosestIntersect(from, to, layerMask, maxDistance);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t SceneInteract_RaycastFurthestIntersect_float3_float3_unsigned(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    float3& from = *GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3& to = *GetCheckedValueObject<float3>(ctx, 1, float3_ID);
    unsigned layerMask = numArgs > 2 ? (unsigned)duk_require_number(ctx, 2) : 0xffffffff;
    float3 ret = thisObj->RaycastFurthestIntersect(from, to, layerMask);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t SceneInteract_RaycastFurthestIntersect_float3_float3Vector_unsigned(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    SceneInteract* thisObj = GetThisWeakObject<SceneInteract>(ctx);
    float3& from = *GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    Vector<float3> to = GetValueObjectVector<float3>(ctx, 1, float3_ID);
    unsigned layerMask = numArgs > 2 ? (unsigned)duk_require_number(ctx, 2) : 0xffffffff;
    float3 ret = thisObj->RaycastFurthestIntersect(from, to, layerMask);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t SceneInteract_RaycastClosestIntersect_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs >= 2 && GetValueObject<float3>(ctx, 0, float3_ID) && duk_is_object(ctx, 1))
        return SceneInteract_RaycastClosestIntersect_float3_float3Vector_unsigned_float(ctx);
    if (numArgs >= 2 && GetValueObject<float3>(ctx, 0, float3_ID) && GetValueObject<float3>(ctx, 1, float3_ID))
        return SceneInteract_RaycastClosestIntersect_float3_float3_unsigned_float(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t SceneInteract_RaycastFurthestIntersect_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs >= 2 && GetValueObject<float3>(ctx, 0, float3_ID) && duk_is_object(ctx, 1))
        return SceneInteract_RaycastFurthestIntersect_float3_float3Vector_unsigned(ctx);
    if (numArgs >= 2 && GetValueObject<float3>(ctx, 0, float3_ID) && GetValueObject<float3>(ctx, 1, float3_ID))
        return SceneInteract_RaycastFurthestIntersect_float3_float3_unsigned(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry SceneInteract_Functions[] = {
    {"CurrentMouseRaycastResult", SceneInteract_CurrentMouseRaycastResult, 0}
    ,{"RaycastClosestIntersect", SceneInteract_RaycastClosestIntersect_Selector, DUK_VARARGS}
    ,{"RaycastFurthestIntersect", SceneInteract_RaycastFurthestIntersect_Selector, DUK_VARARGS}
    ,{nullptr, nullptr, 0}
};

void Expose_SceneInteract(duk_context* ctx)
{
    duk_push_object(ctx);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, SceneInteract_Functions);
    DefineProperty(ctx, "EntityMouseMove", SceneInteract_Get_EntityMouseMove, nullptr);
    DefineProperty(ctx, "EntityMouseScroll", SceneInteract_Get_EntityMouseScroll, nullptr);
    DefineProperty(ctx, "EntityClicked", SceneInteract_Get_EntityClicked, nullptr);
    DefineProperty(ctx, "EntityClickReleased", SceneInteract_Get_EntityClickReleased, nullptr);
    DefineProperty(ctx, "currentMouseRaycastResult", SceneInteract_CurrentMouseRaycastResult, nullptr);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, SceneInteract_ID);
}

}
