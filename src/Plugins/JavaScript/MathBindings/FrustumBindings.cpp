// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "BindingsHelpers.h"
#include "Geometry/Frustum.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif

#include "Math/float3.h"
#include "Geometry/Plane.h"
#include "Geometry/LineSegment.h"
#include "Math/float3x4.h"
#include "Math/float4x4.h"
#include "Geometry/Ray.h"
#include "Math/float2.h"
#include "Algorithm/Random/LCG.h"
#include "Math/float3x3.h"
#include "Math/Quat.h"
#include "Geometry/AABB.h"
#include "Geometry/OBB.h"
#include "Geometry/Triangle.h"
#include "Geometry/Line.h"
#include "Geometry/Sphere.h"
#include "Geometry/Capsule.h"

using namespace std;

namespace JSBindings
{

extern const char* float3_ID;
extern const char* Plane_ID;
extern const char* LineSegment_ID;
extern const char* float3x4_ID;
extern const char* float4x4_ID;
extern const char* Ray_ID;
extern const char* float2_ID;
extern const char* LCG_ID;
extern const char* float3x3_ID;
extern const char* Quat_ID;
extern const char* AABB_ID;
extern const char* OBB_ID;
extern const char* Triangle_ID;
extern const char* Line_ID;
extern const char* Sphere_ID;
extern const char* Capsule_ID;

duk_ret_t float3_Finalizer(duk_context* ctx);
duk_ret_t Plane_Finalizer(duk_context* ctx);
duk_ret_t LineSegment_Finalizer(duk_context* ctx);
duk_ret_t float3x4_Finalizer(duk_context* ctx);
duk_ret_t float4x4_Finalizer(duk_context* ctx);
duk_ret_t Ray_Finalizer(duk_context* ctx);
duk_ret_t float2_Finalizer(duk_context* ctx);
duk_ret_t LCG_Finalizer(duk_context* ctx);
duk_ret_t float3x3_Finalizer(duk_context* ctx);
duk_ret_t Quat_Finalizer(duk_context* ctx);
duk_ret_t AABB_Finalizer(duk_context* ctx);
duk_ret_t OBB_Finalizer(duk_context* ctx);
duk_ret_t Triangle_Finalizer(duk_context* ctx);
duk_ret_t Line_Finalizer(duk_context* ctx);
duk_ret_t Sphere_Finalizer(duk_context* ctx);
duk_ret_t Capsule_Finalizer(duk_context* ctx);

const char* Frustum_ID = "Frustum";

duk_ret_t Frustum_Finalizer(duk_context* ctx)
{
    Frustum* obj = GetValueObject<Frustum>(ctx, 0, Frustum_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, Frustum_ID);
    }
    return 0;
}

static duk_ret_t Frustum_Ctor(duk_context* ctx)
{
    Frustum* newObj = new Frustum();
    PushConstructorResult<Frustum>(ctx, newObj, Frustum_ID, Frustum_Finalizer);
    return 0;
}

static duk_ret_t Frustum_SetViewPlaneDistances_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float nearPlaneDistance = (float)duk_require_number(ctx, 0);
    float farPlaneDistance = (float)duk_require_number(ctx, 1);
    thisObj->SetViewPlaneDistances(nearPlaneDistance, farPlaneDistance);
    return 0;
}

static duk_ret_t Frustum_SetFrame_float3_float3_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* pos = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3* front = GetCheckedValueObject<float3>(ctx, 1, float3_ID);
    float3* up = GetCheckedValueObject<float3>(ctx, 2, float3_ID);
    thisObj->SetFrame(*pos, *front, *up);
    return 0;
}

static duk_ret_t Frustum_SetPos_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* pos = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    thisObj->SetPos(*pos);
    return 0;
}

static duk_ret_t Frustum_SetFront_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* front = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    thisObj->SetFront(*front);
    return 0;
}

static duk_ret_t Frustum_SetUp_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* up = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    thisObj->SetUp(*up);
    return 0;
}

static duk_ret_t Frustum_SetPerspective_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float horizontalFov = (float)duk_require_number(ctx, 0);
    float verticalFov = (float)duk_require_number(ctx, 1);
    thisObj->SetPerspective(horizontalFov, verticalFov);
    return 0;
}

static duk_ret_t Frustum_SetOrthographic_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float orthographicWidth = (float)duk_require_number(ctx, 0);
    float orthographicHeight = (float)duk_require_number(ctx, 1);
    thisObj->SetOrthographic(orthographicWidth, orthographicHeight);
    return 0;
}

static duk_ret_t Frustum_Pos(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    const vec & ret = thisObj->Pos();
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Front(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    const vec & ret = thisObj->Front();
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Up(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    const vec & ret = thisObj->Up();
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_NearPlaneDistance(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->NearPlaneDistance();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_FarPlaneDistance(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->FarPlaneDistance();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_HorizontalFov(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->HorizontalFov();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_VerticalFov(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->VerticalFov();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_OrthographicWidth(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->OrthographicWidth();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_OrthographicHeight(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->OrthographicHeight();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_NumEdges(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    int ret = thisObj->NumEdges();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_AspectRatio(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->AspectRatio();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_SetHorizontalFovAndAspectRatio_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float horizontalFov = (float)duk_require_number(ctx, 0);
    float aspectRatio = (float)duk_require_number(ctx, 1);
    thisObj->SetHorizontalFovAndAspectRatio(horizontalFov, aspectRatio);
    return 0;
}

static duk_ret_t Frustum_SetVerticalFovAndAspectRatio_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float verticalFov = (float)duk_require_number(ctx, 0);
    float aspectRatio = (float)duk_require_number(ctx, 1);
    thisObj->SetVerticalFovAndAspectRatio(verticalFov, aspectRatio);
    return 0;
}

static duk_ret_t Frustum_WorldRight(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3 ret = thisObj->WorldRight();
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_NearPlane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane ret = thisObj->NearPlane();
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_NearPlaneWidth(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->NearPlaneWidth();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_NearPlaneHeight(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->NearPlaneHeight();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_FarPlane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane ret = thisObj->FarPlane();
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_LeftPlane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane ret = thisObj->LeftPlane();
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_RightPlane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane ret = thisObj->RightPlane();
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_TopPlane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane ret = thisObj->TopPlane();
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_BottomPlane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane ret = thisObj->BottomPlane();
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_GetPlane_int(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    int faceIndex = (int)duk_require_number(ctx, 0);
    Plane ret = thisObj->GetPlane(faceIndex);
    PushValueObjectCopy<Plane>(ctx, ret, Plane_ID, Plane_Finalizer);
    return 1;
}

static duk_ret_t Frustum_CenterPoint(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3 ret = thisObj->CenterPoint();
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Edge_int(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    int edgeIndex = (int)duk_require_number(ctx, 0);
    LineSegment ret = thisObj->Edge(edgeIndex);
    PushValueObjectCopy<LineSegment>(ctx, ret, LineSegment_ID, LineSegment_Finalizer);
    return 1;
}

static duk_ret_t Frustum_CornerPoint_int(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    int cornerIndex = (int)duk_require_number(ctx, 0);
    float3 ret = thisObj->CornerPoint(cornerIndex);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_AnyPointFast(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3 ret = thisObj->AnyPointFast();
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ExtremePoint_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* direction = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3 ret = thisObj->ExtremePoint(*direction);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ExtremePoint_float3_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* direction = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float projectionDistance = (float)duk_require_number(ctx, 1);
    float3 ret = thisObj->ExtremePoint(*direction, projectionDistance);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ProjectToAxis_float3_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* direction = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float outMin = (float)duk_require_number(ctx, 1);
    float outMax = (float)duk_require_number(ctx, 2);
    thisObj->ProjectToAxis(*direction, outMin, outMax);
    return 0;
}

static duk_ret_t Frustum_SetWorldMatrix_float3x4(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x4* worldTransform = GetCheckedValueObject<float3x4>(ctx, 0, float3x4_ID);
    thisObj->SetWorldMatrix(*worldTransform);
    return 0;
}

static duk_ret_t Frustum_WorldMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x4 ret = thisObj->WorldMatrix();
    PushValueObjectCopy<float3x4>(ctx, ret, float3x4_ID, float3x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ComputeWorldMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x4 ret = thisObj->ComputeWorldMatrix();
    PushValueObjectCopy<float3x4>(ctx, ret, float3x4_ID, float3x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ViewMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x4 ret = thisObj->ViewMatrix();
    PushValueObjectCopy<float3x4>(ctx, ret, float3x4_ID, float3x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ComputeViewMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x4 ret = thisObj->ComputeViewMatrix();
    PushValueObjectCopy<float3x4>(ctx, ret, float3x4_ID, float3x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ProjectionMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float4x4 ret = thisObj->ProjectionMatrix();
    PushValueObjectCopy<float4x4>(ctx, ret, float4x4_ID, float4x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ComputeProjectionMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float4x4 ret = thisObj->ComputeProjectionMatrix();
    PushValueObjectCopy<float4x4>(ctx, ret, float4x4_ID, float4x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ViewProjMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float4x4 ret = thisObj->ViewProjMatrix();
    PushValueObjectCopy<float4x4>(ctx, ret, float4x4_ID, float4x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ComputeViewProjMatrix(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float4x4 ret = thisObj->ComputeViewProjMatrix();
    PushValueObjectCopy<float4x4>(ctx, ret, float4x4_ID, float4x4_Finalizer);
    return 1;
}

static duk_ret_t Frustum_UnProject_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    Ray ret = thisObj->UnProject(x, y);
    PushValueObjectCopy<Ray>(ctx, ret, Ray_ID, Ray_Finalizer);
    return 1;
}

static duk_ret_t Frustum_UnProject_float2(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float2* xy = GetCheckedValueObject<float2>(ctx, 0, float2_ID);
    Ray ret = thisObj->UnProject(*xy);
    PushValueObjectCopy<Ray>(ctx, ret, Ray_ID, Ray_Finalizer);
    return 1;
}

static duk_ret_t Frustum_UnProjectFromNearPlane_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    Ray ret = thisObj->UnProjectFromNearPlane(x, y);
    PushValueObjectCopy<Ray>(ctx, ret, Ray_ID, Ray_Finalizer);
    return 1;
}

static duk_ret_t Frustum_UnProjectLineSegment_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    LineSegment ret = thisObj->UnProjectLineSegment(x, y);
    PushValueObjectCopy<LineSegment>(ctx, ret, LineSegment_ID, LineSegment_Finalizer);
    return 1;
}

static duk_ret_t Frustum_PointInside_float_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    float z = (float)duk_require_number(ctx, 2);
    float3 ret = thisObj->PointInside(x, y, z);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_PointInside_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* xyz = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3 ret = thisObj->PointInside(*xyz);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Project_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* point = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3 ret = thisObj->Project(*point);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_NearPlanePos_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    float3 ret = thisObj->NearPlanePos(x, y);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_NearPlanePos_float2(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float2* point = GetCheckedValueObject<float2>(ctx, 0, float2_ID);
    float3 ret = thisObj->NearPlanePos(*point);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_FarPlanePos_float_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    float3 ret = thisObj->FarPlanePos(x, y);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_FarPlanePos_float2(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float2* point = GetCheckedValueObject<float2>(ctx, 0, float2_ID);
    float3 ret = thisObj->FarPlanePos(*point);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_IsFinite(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    bool ret = thisObj->IsFinite();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Volume(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float ret = thisObj->Volume();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_FastRandomPointInside_LCG(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    LCG* rng = GetCheckedValueObject<LCG>(ctx, 0, LCG_ID);
    float3 ret = thisObj->FastRandomPointInside(*rng);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_UniformRandomPointInside_LCG(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    LCG* rng = GetCheckedValueObject<LCG>(ctx, 0, LCG_ID);
    float3 ret = thisObj->UniformRandomPointInside(*rng);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Translate_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* offset = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    thisObj->Translate(*offset);
    return 0;
}

static duk_ret_t Frustum_Transform_float3x3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x3* transform = GetCheckedValueObject<float3x3>(ctx, 0, float3x3_ID);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Frustum_Transform_float3x4(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3x4* transform = GetCheckedValueObject<float3x4>(ctx, 0, float3x4_ID);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Frustum_Transform_float4x4(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float4x4* transform = GetCheckedValueObject<float4x4>(ctx, 0, float4x4_ID);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Frustum_Transform_Quat(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Quat* transform = GetCheckedValueObject<Quat>(ctx, 0, Quat_ID);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Frustum_MinimalEnclosingAABB(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    AABB ret = thisObj->MinimalEnclosingAABB();
    PushValueObjectCopy<AABB>(ctx, ret, AABB_ID, AABB_Finalizer);
    return 1;
}

static duk_ret_t Frustum_MinimalEnclosingOBB_float(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float expandGuardband = (float)duk_require_number(ctx, 0);
    OBB ret = thisObj->MinimalEnclosingOBB(expandGuardband);
    PushValueObjectCopy<OBB>(ctx, ret, OBB_ID, OBB_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Contains_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* point = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    bool ret = thisObj->Contains(*point);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Contains_LineSegment(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    LineSegment* lineSegment = GetCheckedValueObject<LineSegment>(ctx, 0, LineSegment_ID);
    bool ret = thisObj->Contains(*lineSegment);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Contains_Triangle(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Triangle* triangle = GetCheckedValueObject<Triangle>(ctx, 0, Triangle_ID);
    bool ret = thisObj->Contains(*triangle);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Contains_AABB(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    AABB* aabb = GetCheckedValueObject<AABB>(ctx, 0, AABB_ID);
    bool ret = thisObj->Contains(*aabb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Contains_OBB(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_ID);
    bool ret = thisObj->Contains(*obb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Contains_Frustum(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Frustum* frustum = GetCheckedValueObject<Frustum>(ctx, 0, Frustum_ID);
    bool ret = thisObj->Contains(*frustum);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_ClosestPoint_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* point = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float3 ret = thisObj->ClosestPoint(*point);
    PushValueObjectCopy<float3>(ctx, ret, float3_ID, float3_Finalizer);
    return 1;
}

static duk_ret_t Frustum_Distance_float3(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    float3* point = GetCheckedValueObject<float3>(ctx, 0, float3_ID);
    float ret = thisObj->Distance(*point);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Ray(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Ray* ray = GetCheckedValueObject<Ray>(ctx, 0, Ray_ID);
    bool ret = thisObj->Intersects(*ray);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Line(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Line* line = GetCheckedValueObject<Line>(ctx, 0, Line_ID);
    bool ret = thisObj->Intersects(*line);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_LineSegment(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    LineSegment* lineSegment = GetCheckedValueObject<LineSegment>(ctx, 0, LineSegment_ID);
    bool ret = thisObj->Intersects(*lineSegment);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_AABB(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    AABB* aabb = GetCheckedValueObject<AABB>(ctx, 0, AABB_ID);
    bool ret = thisObj->Intersects(*aabb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_OBB(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_ID);
    bool ret = thisObj->Intersects(*obb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Plane(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Plane* plane = GetCheckedValueObject<Plane>(ctx, 0, Plane_ID);
    bool ret = thisObj->Intersects(*plane);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Triangle(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Triangle* triangle = GetCheckedValueObject<Triangle>(ctx, 0, Triangle_ID);
    bool ret = thisObj->Intersects(*triangle);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Sphere(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Sphere* sphere = GetCheckedValueObject<Sphere>(ctx, 0, Sphere_ID);
    bool ret = thisObj->Intersects(*sphere);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Capsule(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Capsule* capsule = GetCheckedValueObject<Capsule>(ctx, 0, Capsule_ID);
    bool ret = thisObj->Intersects(*capsule);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_Intersects_Frustum(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    Frustum* frustum = GetCheckedValueObject<Frustum>(ctx, 0, Frustum_ID);
    bool ret = thisObj->Intersects(*frustum);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Frustum_ToString(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    string ret = thisObj->ToString();
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t Frustum_SerializeToString(duk_context* ctx)
{
    Frustum* thisObj = GetThisValueObject<Frustum>(ctx, Frustum_ID);
    string ret = thisObj->SerializeToString();
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t Frustum_ExtremePoint_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<float3>(ctx, 0, float3_ID))
        return Frustum_ExtremePoint_float3(ctx);
    if (numArgs == 2 && GetValueObject<float3>(ctx, 0, float3_ID) && duk_is_number(ctx, 1))
        return Frustum_ExtremePoint_float3_float(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_UnProject_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 2 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1))
        return Frustum_UnProject_float_float(ctx);
    if (numArgs == 1 && GetValueObject<float2>(ctx, 0, float2_ID))
        return Frustum_UnProject_float2(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_PointInside_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 3 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return Frustum_PointInside_float_float_float(ctx);
    if (numArgs == 1 && GetValueObject<float3>(ctx, 0, float3_ID))
        return Frustum_PointInside_float3(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_NearPlanePos_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 2 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1))
        return Frustum_NearPlanePos_float_float(ctx);
    if (numArgs == 1 && GetValueObject<float2>(ctx, 0, float2_ID))
        return Frustum_NearPlanePos_float2(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_FarPlanePos_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 2 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1))
        return Frustum_FarPlanePos_float_float(ctx);
    if (numArgs == 1 && GetValueObject<float2>(ctx, 0, float2_ID))
        return Frustum_FarPlanePos_float2(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_Transform_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<float3x3>(ctx, 0, float3x3_ID))
        return Frustum_Transform_float3x3(ctx);
    if (numArgs == 1 && GetValueObject<float3x4>(ctx, 0, float3x4_ID))
        return Frustum_Transform_float3x4(ctx);
    if (numArgs == 1 && GetValueObject<float4x4>(ctx, 0, float4x4_ID))
        return Frustum_Transform_float4x4(ctx);
    if (numArgs == 1 && GetValueObject<Quat>(ctx, 0, Quat_ID))
        return Frustum_Transform_Quat(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_Contains_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<float3>(ctx, 0, float3_ID))
        return Frustum_Contains_float3(ctx);
    if (numArgs == 1 && GetValueObject<LineSegment>(ctx, 0, LineSegment_ID))
        return Frustum_Contains_LineSegment(ctx);
    if (numArgs == 1 && GetValueObject<Triangle>(ctx, 0, Triangle_ID))
        return Frustum_Contains_Triangle(ctx);
    if (numArgs == 1 && GetValueObject<AABB>(ctx, 0, AABB_ID))
        return Frustum_Contains_AABB(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_ID))
        return Frustum_Contains_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Frustum>(ctx, 0, Frustum_ID))
        return Frustum_Contains_Frustum(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_Intersects_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<Ray>(ctx, 0, Ray_ID))
        return Frustum_Intersects_Ray(ctx);
    if (numArgs == 1 && GetValueObject<Line>(ctx, 0, Line_ID))
        return Frustum_Intersects_Line(ctx);
    if (numArgs == 1 && GetValueObject<LineSegment>(ctx, 0, LineSegment_ID))
        return Frustum_Intersects_LineSegment(ctx);
    if (numArgs == 1 && GetValueObject<AABB>(ctx, 0, AABB_ID))
        return Frustum_Intersects_AABB(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_ID))
        return Frustum_Intersects_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Plane>(ctx, 0, Plane_ID))
        return Frustum_Intersects_Plane(ctx);
    if (numArgs == 1 && GetValueObject<Triangle>(ctx, 0, Triangle_ID))
        return Frustum_Intersects_Triangle(ctx);
    if (numArgs == 1 && GetValueObject<Sphere>(ctx, 0, Sphere_ID))
        return Frustum_Intersects_Sphere(ctx);
    if (numArgs == 1 && GetValueObject<Capsule>(ctx, 0, Capsule_ID))
        return Frustum_Intersects_Capsule(ctx);
    if (numArgs == 1 && GetValueObject<Frustum>(ctx, 0, Frustum_ID))
        return Frustum_Intersects_Frustum(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_ViewportToScreenSpace_Static_float_float_int_int(duk_context* ctx)
{
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    int screenWidth = (int)duk_require_number(ctx, 2);
    int screenHeight = (int)duk_require_number(ctx, 3);
    float2 ret = Frustum::ViewportToScreenSpace(x, y, screenWidth, screenHeight);
    PushValueObjectCopy<float2>(ctx, ret, float2_ID, float2_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ViewportToScreenSpace_Static_float2_int_int(duk_context* ctx)
{
    float2* point = GetCheckedValueObject<float2>(ctx, 0, float2_ID);
    int screenWidth = (int)duk_require_number(ctx, 1);
    int screenHeight = (int)duk_require_number(ctx, 2);
    float2 ret = Frustum::ViewportToScreenSpace(*point, screenWidth, screenHeight);
    PushValueObjectCopy<float2>(ctx, ret, float2_ID, float2_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ScreenToViewportSpace_Static_float_float_int_int(duk_context* ctx)
{
    float x = (float)duk_require_number(ctx, 0);
    float y = (float)duk_require_number(ctx, 1);
    int screenWidth = (int)duk_require_number(ctx, 2);
    int screenHeight = (int)duk_require_number(ctx, 3);
    float2 ret = Frustum::ScreenToViewportSpace(x, y, screenWidth, screenHeight);
    PushValueObjectCopy<float2>(ctx, ret, float2_ID, float2_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ScreenToViewportSpace_Static_float2_int_int(duk_context* ctx)
{
    float2* point = GetCheckedValueObject<float2>(ctx, 0, float2_ID);
    int screenWidth = (int)duk_require_number(ctx, 1);
    int screenHeight = (int)duk_require_number(ctx, 2);
    float2 ret = Frustum::ScreenToViewportSpace(*point, screenWidth, screenHeight);
    PushValueObjectCopy<float2>(ctx, ret, float2_ID, float2_Finalizer);
    return 1;
}

static duk_ret_t Frustum_ViewportToScreenSpace_Static_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 4 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2) && duk_is_number(ctx, 3))
        return Frustum_ViewportToScreenSpace_Static_float_float_int_int(ctx);
    if (numArgs == 3 && GetValueObject<float2>(ctx, 0, float2_ID) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return Frustum_ViewportToScreenSpace_Static_float2_int_int(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Frustum_ScreenToViewportSpace_Static_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 4 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2) && duk_is_number(ctx, 3))
        return Frustum_ScreenToViewportSpace_Static_float_float_int_int(ctx);
    if (numArgs == 3 && GetValueObject<float2>(ctx, 0, float2_ID) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return Frustum_ScreenToViewportSpace_Static_float2_int_int(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry Frustum_Functions[] = {
    {"SetViewPlaneDistances", Frustum_SetViewPlaneDistances_float_float, 2}
    ,{"SetFrame", Frustum_SetFrame_float3_float3_float3, 3}
    ,{"SetPos", Frustum_SetPos_float3, 1}
    ,{"SetFront", Frustum_SetFront_float3, 1}
    ,{"SetUp", Frustum_SetUp_float3, 1}
    ,{"SetPerspective", Frustum_SetPerspective_float_float, 2}
    ,{"SetOrthographic", Frustum_SetOrthographic_float_float, 2}
    ,{"Pos", Frustum_Pos, 0}
    ,{"Front", Frustum_Front, 0}
    ,{"Up", Frustum_Up, 0}
    ,{"NearPlaneDistance", Frustum_NearPlaneDistance, 0}
    ,{"FarPlaneDistance", Frustum_FarPlaneDistance, 0}
    ,{"HorizontalFov", Frustum_HorizontalFov, 0}
    ,{"VerticalFov", Frustum_VerticalFov, 0}
    ,{"OrthographicWidth", Frustum_OrthographicWidth, 0}
    ,{"OrthographicHeight", Frustum_OrthographicHeight, 0}
    ,{"NumEdges", Frustum_NumEdges, 0}
    ,{"AspectRatio", Frustum_AspectRatio, 0}
    ,{"SetHorizontalFovAndAspectRatio", Frustum_SetHorizontalFovAndAspectRatio_float_float, 2}
    ,{"SetVerticalFovAndAspectRatio", Frustum_SetVerticalFovAndAspectRatio_float_float, 2}
    ,{"WorldRight", Frustum_WorldRight, 0}
    ,{"NearPlane", Frustum_NearPlane, 0}
    ,{"NearPlaneWidth", Frustum_NearPlaneWidth, 0}
    ,{"NearPlaneHeight", Frustum_NearPlaneHeight, 0}
    ,{"FarPlane", Frustum_FarPlane, 0}
    ,{"LeftPlane", Frustum_LeftPlane, 0}
    ,{"RightPlane", Frustum_RightPlane, 0}
    ,{"TopPlane", Frustum_TopPlane, 0}
    ,{"BottomPlane", Frustum_BottomPlane, 0}
    ,{"GetPlane", Frustum_GetPlane_int, 1}
    ,{"CenterPoint", Frustum_CenterPoint, 0}
    ,{"Edge", Frustum_Edge_int, 1}
    ,{"CornerPoint", Frustum_CornerPoint_int, 1}
    ,{"AnyPointFast", Frustum_AnyPointFast, 0}
    ,{"ExtremePoint", Frustum_ExtremePoint_Selector, DUK_VARARGS}
    ,{"ProjectToAxis", Frustum_ProjectToAxis_float3_float_float, 3}
    ,{"SetWorldMatrix", Frustum_SetWorldMatrix_float3x4, 1}
    ,{"WorldMatrix", Frustum_WorldMatrix, 0}
    ,{"ComputeWorldMatrix", Frustum_ComputeWorldMatrix, 0}
    ,{"ViewMatrix", Frustum_ViewMatrix, 0}
    ,{"ComputeViewMatrix", Frustum_ComputeViewMatrix, 0}
    ,{"ProjectionMatrix", Frustum_ProjectionMatrix, 0}
    ,{"ComputeProjectionMatrix", Frustum_ComputeProjectionMatrix, 0}
    ,{"ViewProjMatrix", Frustum_ViewProjMatrix, 0}
    ,{"ComputeViewProjMatrix", Frustum_ComputeViewProjMatrix, 0}
    ,{"UnProject", Frustum_UnProject_Selector, DUK_VARARGS}
    ,{"UnProjectFromNearPlane", Frustum_UnProjectFromNearPlane_float_float, 2}
    ,{"UnProjectLineSegment", Frustum_UnProjectLineSegment_float_float, 2}
    ,{"PointInside", Frustum_PointInside_Selector, DUK_VARARGS}
    ,{"Project", Frustum_Project_float3, 1}
    ,{"NearPlanePos", Frustum_NearPlanePos_Selector, DUK_VARARGS}
    ,{"FarPlanePos", Frustum_FarPlanePos_Selector, DUK_VARARGS}
    ,{"IsFinite", Frustum_IsFinite, 0}
    ,{"Volume", Frustum_Volume, 0}
    ,{"FastRandomPointInside", Frustum_FastRandomPointInside_LCG, 1}
    ,{"UniformRandomPointInside", Frustum_UniformRandomPointInside_LCG, 1}
    ,{"Translate", Frustum_Translate_float3, 1}
    ,{"Transform", Frustum_Transform_Selector, DUK_VARARGS}
    ,{"MinimalEnclosingAABB", Frustum_MinimalEnclosingAABB, 0}
    ,{"MinimalEnclosingOBB", Frustum_MinimalEnclosingOBB_float, 1}
    ,{"Contains", Frustum_Contains_Selector, DUK_VARARGS}
    ,{"ClosestPoint", Frustum_ClosestPoint_float3, 1}
    ,{"Distance", Frustum_Distance_float3, 1}
    ,{"Intersects", Frustum_Intersects_Selector, DUK_VARARGS}
    ,{"ToString", Frustum_ToString, 0}
    ,{"SerializeToString", Frustum_SerializeToString, 0}
    ,{nullptr, nullptr, 0}
};

static const duk_function_list_entry Frustum_StaticFunctions[] = {
    {"ViewportToScreenSpace", Frustum_ViewportToScreenSpace_Static_Selector, DUK_VARARGS}
    ,{"ScreenToViewportSpace", Frustum_ScreenToViewportSpace_Static_Selector, DUK_VARARGS}
    ,{nullptr, nullptr, 0}
};

void Expose_Frustum(duk_context* ctx)
{
    duk_push_c_function(ctx, Frustum_Ctor, DUK_VARARGS);
    duk_put_function_list(ctx, -1, Frustum_StaticFunctions);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, Frustum_Functions);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, Frustum_ID);
}

}
