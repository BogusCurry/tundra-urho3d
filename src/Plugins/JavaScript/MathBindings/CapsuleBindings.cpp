// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "BindingsHelpers.h"
#include "Geometry/Capsule.h"
#include "Geometry/LineSegment.h"
#include "Geometry/Sphere.h"
#include "Geometry/Circle.h"
#include "Geometry/AABB.h"
#include "Geometry/OBB.h"
#include "Algorithm/Random/LCG.h"
#include "Math/float3x3.h"
#include "Math/float3x4.h"
#include "Math/float4x4.h"
#include "Math/Quat.h"
#include "Geometry/Plane.h"
#include "Geometry/Ray.h"
#include "Geometry/Line.h"
#include "Geometry/Triangle.h"
#include "Geometry/Frustum.h"

namespace JSBindings
{

extern const char* LineSegment_Id;
extern const char* Sphere_Id;
extern const char* Circle_Id;
extern const char* AABB_Id;
extern const char* OBB_Id;
extern const char* LCG_Id;
extern const char* float3x3_Id;
extern const char* float3x4_Id;
extern const char* float4x4_Id;
extern const char* Quat_Id;
extern const char* Plane_Id;
extern const char* Ray_Id;
extern const char* Line_Id;
extern const char* Triangle_Id;
extern const char* Frustum_Id;

duk_ret_t LineSegment_Dtor(duk_context* ctx);
duk_ret_t Sphere_Dtor(duk_context* ctx);
duk_ret_t Circle_Dtor(duk_context* ctx);
duk_ret_t AABB_Dtor(duk_context* ctx);
duk_ret_t OBB_Dtor(duk_context* ctx);
duk_ret_t LCG_Dtor(duk_context* ctx);
duk_ret_t float3x3_Dtor(duk_context* ctx);
duk_ret_t float3x4_Dtor(duk_context* ctx);
duk_ret_t float4x4_Dtor(duk_context* ctx);
duk_ret_t Quat_Dtor(duk_context* ctx);
duk_ret_t Plane_Dtor(duk_context* ctx);
duk_ret_t Ray_Dtor(duk_context* ctx);
duk_ret_t Line_Dtor(duk_context* ctx);
duk_ret_t Triangle_Dtor(duk_context* ctx);
duk_ret_t Frustum_Dtor(duk_context* ctx);

const char* Capsule_Id = "Capsule";

duk_ret_t Capsule_Dtor(duk_context* ctx)
{
    Capsule* obj = GetObject<Capsule>(ctx, 0, Capsule_Id);
    if (obj)
    {
        delete obj;
        SetObject(ctx, 0, 0, Capsule_Id);
    }
    return 0;
}

static duk_ret_t Capsule_Set_r(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float r = (float)duk_require_number(ctx, 0);
    thisObj->r = r;
    return 0;
}

static duk_ret_t Capsule_Get_r(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    duk_push_number(ctx, thisObj->r);
    return 1;
}

static duk_ret_t Capsule_Ctor(duk_context* ctx)
{
    Capsule* newObj = new Capsule();
    PushConstructorResult<Capsule>(ctx, newObj, Capsule_Id, Capsule_Dtor);
    return 0;
}

static duk_ret_t Capsule_Ctor_LineSegment_float(duk_context* ctx)
{
    LineSegment* endPoints = GetCheckedObject<LineSegment>(ctx, 0, LineSegment_Id);
    float radius = (float)duk_require_number(ctx, 1);
    Capsule* newObj = new Capsule(*endPoints, radius);
    PushConstructorResult<Capsule>(ctx, newObj, Capsule_Id, Capsule_Dtor);
    return 0;
}

static duk_ret_t Capsule_SetFrom_Sphere(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Sphere* s = GetCheckedObject<Sphere>(ctx, 0, Sphere_Id);
    thisObj->SetFrom(*s);
    return 0;
}

static duk_ret_t Capsule_SetDegenerate(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    thisObj->SetDegenerate();
    return 0;
}

static duk_ret_t Capsule_IsDegenerate(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    bool ret = thisObj->IsDegenerate();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_LineLength(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float ret = thisObj->LineLength();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Height(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float ret = thisObj->Height();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Diameter(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float ret = thisObj->Diameter();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Volume(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float ret = thisObj->Volume();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_SurfaceArea(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float ret = thisObj->SurfaceArea();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_CrossSection_float(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float l = (float)duk_require_number(ctx, 0);
    Circle ret = thisObj->CrossSection(l);
    PushValueObjectCopy<Circle>(ctx, ret, Circle_Id, Circle_Dtor);
    return 1;
}

static duk_ret_t Capsule_HeightLineSegment(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    LineSegment ret = thisObj->HeightLineSegment();
    PushValueObjectCopy<LineSegment>(ctx, ret, LineSegment_Id, LineSegment_Dtor);
    return 1;
}

static duk_ret_t Capsule_IsFinite(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    bool ret = thisObj->IsFinite();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_SphereA(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Sphere ret = thisObj->SphereA();
    PushValueObjectCopy<Sphere>(ctx, ret, Sphere_Id, Sphere_Dtor);
    return 1;
}

static duk_ret_t Capsule_SphereB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Sphere ret = thisObj->SphereB();
    PushValueObjectCopy<Sphere>(ctx, ret, Sphere_Id, Sphere_Dtor);
    return 1;
}

static duk_ret_t Capsule_MinimalEnclosingAABB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    AABB ret = thisObj->MinimalEnclosingAABB();
    PushValueObjectCopy<AABB>(ctx, ret, AABB_Id, AABB_Dtor);
    return 1;
}

static duk_ret_t Capsule_MinimalEnclosingOBB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    OBB ret = thisObj->MinimalEnclosingOBB();
    PushValueObjectCopy<OBB>(ctx, ret, OBB_Id, OBB_Dtor);
    return 1;
}

static duk_ret_t Capsule_Transform_float3x3(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float3x3* transform = GetCheckedObject<float3x3>(ctx, 0, float3x3_Id);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Capsule_Transform_float3x4(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float3x4* transform = GetCheckedObject<float3x4>(ctx, 0, float3x4_Id);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Capsule_Transform_float4x4(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    float4x4* transform = GetCheckedObject<float4x4>(ctx, 0, float4x4_Id);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Capsule_Transform_Quat(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Quat* transform = GetCheckedObject<Quat>(ctx, 0, Quat_Id);
    thisObj->Transform(*transform);
    return 0;
}

static duk_ret_t Capsule_Distance_Plane(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Plane* plane = GetCheckedObject<Plane>(ctx, 0, Plane_Id);
    float ret = thisObj->Distance(*plane);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Distance_Sphere(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Sphere* sphere = GetCheckedObject<Sphere>(ctx, 0, Sphere_Id);
    float ret = thisObj->Distance(*sphere);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Distance_Ray(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Ray* ray = GetCheckedObject<Ray>(ctx, 0, Ray_Id);
    float ret = thisObj->Distance(*ray);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Distance_Line(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Line* line = GetCheckedObject<Line>(ctx, 0, Line_Id);
    float ret = thisObj->Distance(*line);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Distance_LineSegment(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    LineSegment* lineSegment = GetCheckedObject<LineSegment>(ctx, 0, LineSegment_Id);
    float ret = thisObj->Distance(*lineSegment);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Distance_Capsule(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Capsule* capsule = GetCheckedObject<Capsule>(ctx, 0, Capsule_Id);
    float ret = thisObj->Distance(*capsule);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Contains_LineSegment(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    LineSegment* lineSegment = GetCheckedObject<LineSegment>(ctx, 0, LineSegment_Id);
    bool ret = thisObj->Contains(*lineSegment);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Contains_Triangle(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Triangle* triangle = GetCheckedObject<Triangle>(ctx, 0, Triangle_Id);
    bool ret = thisObj->Contains(*triangle);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Contains_AABB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    AABB* aabb = GetCheckedObject<AABB>(ctx, 0, AABB_Id);
    bool ret = thisObj->Contains(*aabb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Contains_OBB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    OBB* obb = GetCheckedObject<OBB>(ctx, 0, OBB_Id);
    bool ret = thisObj->Contains(*obb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Contains_Frustum(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Frustum* frustum = GetCheckedObject<Frustum>(ctx, 0, Frustum_Id);
    bool ret = thisObj->Contains(*frustum);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Ray(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Ray* ray = GetCheckedObject<Ray>(ctx, 0, Ray_Id);
    bool ret = thisObj->Intersects(*ray);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Line(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Line* line = GetCheckedObject<Line>(ctx, 0, Line_Id);
    bool ret = thisObj->Intersects(*line);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_LineSegment(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    LineSegment* lineSegment = GetCheckedObject<LineSegment>(ctx, 0, LineSegment_Id);
    bool ret = thisObj->Intersects(*lineSegment);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Plane(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Plane* plane = GetCheckedObject<Plane>(ctx, 0, Plane_Id);
    bool ret = thisObj->Intersects(*plane);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Sphere(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Sphere* sphere = GetCheckedObject<Sphere>(ctx, 0, Sphere_Id);
    bool ret = thisObj->Intersects(*sphere);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Capsule(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Capsule* capsule = GetCheckedObject<Capsule>(ctx, 0, Capsule_Id);
    bool ret = thisObj->Intersects(*capsule);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_AABB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    AABB* aabb = GetCheckedObject<AABB>(ctx, 0, AABB_Id);
    bool ret = thisObj->Intersects(*aabb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_OBB(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    OBB* obb = GetCheckedObject<OBB>(ctx, 0, OBB_Id);
    bool ret = thisObj->Intersects(*obb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Triangle(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Triangle* triangle = GetCheckedObject<Triangle>(ctx, 0, Triangle_Id);
    bool ret = thisObj->Intersects(*triangle);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Intersects_Frustum(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Frustum* frustum = GetCheckedObject<Frustum>(ctx, 0, Frustum_Id);
    bool ret = thisObj->Intersects(*frustum);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Equals_Capsule_float(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Capsule* rhs = GetCheckedObject<Capsule>(ctx, 0, Capsule_Id);
    float epsilon = (float)duk_require_number(ctx, 1);
    bool ret = thisObj->Equals(*rhs, epsilon);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_BitEquals_Capsule(duk_context* ctx)
{
    Capsule* thisObj = GetThisObject<Capsule>(ctx, Capsule_Id);
    Capsule* other = GetCheckedObject<Capsule>(ctx, 0, Capsule_Id);
    bool ret = thisObj->BitEquals(*other);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Capsule_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 0)
        return Capsule_Ctor(ctx);
    if (numArgs == 2 && GetObject<LineSegment>(ctx, 0, LineSegment_Id) && duk_is_number(ctx, 1))
        return Capsule_Ctor_LineSegment_float(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Capsule_Transform_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetObject<float3x3>(ctx, 0, float3x3_Id))
        return Capsule_Transform_float3x3(ctx);
    if (numArgs == 1 && GetObject<float3x4>(ctx, 0, float3x4_Id))
        return Capsule_Transform_float3x4(ctx);
    if (numArgs == 1 && GetObject<float4x4>(ctx, 0, float4x4_Id))
        return Capsule_Transform_float4x4(ctx);
    if (numArgs == 1 && GetObject<Quat>(ctx, 0, Quat_Id))
        return Capsule_Transform_Quat(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Capsule_Distance_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetObject<Plane>(ctx, 0, Plane_Id))
        return Capsule_Distance_Plane(ctx);
    if (numArgs == 1 && GetObject<Sphere>(ctx, 0, Sphere_Id))
        return Capsule_Distance_Sphere(ctx);
    if (numArgs == 1 && GetObject<Ray>(ctx, 0, Ray_Id))
        return Capsule_Distance_Ray(ctx);
    if (numArgs == 1 && GetObject<Line>(ctx, 0, Line_Id))
        return Capsule_Distance_Line(ctx);
    if (numArgs == 1 && GetObject<LineSegment>(ctx, 0, LineSegment_Id))
        return Capsule_Distance_LineSegment(ctx);
    if (numArgs == 1 && GetObject<Capsule>(ctx, 0, Capsule_Id))
        return Capsule_Distance_Capsule(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Capsule_Contains_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetObject<LineSegment>(ctx, 0, LineSegment_Id))
        return Capsule_Contains_LineSegment(ctx);
    if (numArgs == 1 && GetObject<Triangle>(ctx, 0, Triangle_Id))
        return Capsule_Contains_Triangle(ctx);
    if (numArgs == 1 && GetObject<AABB>(ctx, 0, AABB_Id))
        return Capsule_Contains_AABB(ctx);
    if (numArgs == 1 && GetObject<OBB>(ctx, 0, OBB_Id))
        return Capsule_Contains_OBB(ctx);
    if (numArgs == 1 && GetObject<Frustum>(ctx, 0, Frustum_Id))
        return Capsule_Contains_Frustum(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t Capsule_Intersects_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetObject<Ray>(ctx, 0, Ray_Id))
        return Capsule_Intersects_Ray(ctx);
    if (numArgs == 1 && GetObject<Line>(ctx, 0, Line_Id))
        return Capsule_Intersects_Line(ctx);
    if (numArgs == 1 && GetObject<LineSegment>(ctx, 0, LineSegment_Id))
        return Capsule_Intersects_LineSegment(ctx);
    if (numArgs == 1 && GetObject<Plane>(ctx, 0, Plane_Id))
        return Capsule_Intersects_Plane(ctx);
    if (numArgs == 1 && GetObject<Sphere>(ctx, 0, Sphere_Id))
        return Capsule_Intersects_Sphere(ctx);
    if (numArgs == 1 && GetObject<Capsule>(ctx, 0, Capsule_Id))
        return Capsule_Intersects_Capsule(ctx);
    if (numArgs == 1 && GetObject<AABB>(ctx, 0, AABB_Id))
        return Capsule_Intersects_AABB(ctx);
    if (numArgs == 1 && GetObject<OBB>(ctx, 0, OBB_Id))
        return Capsule_Intersects_OBB(ctx);
    if (numArgs == 1 && GetObject<Triangle>(ctx, 0, Triangle_Id))
        return Capsule_Intersects_Triangle(ctx);
    if (numArgs == 1 && GetObject<Frustum>(ctx, 0, Frustum_Id))
        return Capsule_Intersects_Frustum(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry Capsule_Functions[] = {
    {"SetFrom", Capsule_SetFrom_Sphere, 1}
    ,{"SetDegenerate", Capsule_SetDegenerate, 0}
    ,{"IsDegenerate", Capsule_IsDegenerate, 0}
    ,{"LineLength", Capsule_LineLength, 0}
    ,{"Height", Capsule_Height, 0}
    ,{"Diameter", Capsule_Diameter, 0}
    ,{"Volume", Capsule_Volume, 0}
    ,{"SurfaceArea", Capsule_SurfaceArea, 0}
    ,{"CrossSection", Capsule_CrossSection_float, 1}
    ,{"HeightLineSegment", Capsule_HeightLineSegment, 0}
    ,{"IsFinite", Capsule_IsFinite, 0}
    ,{"SphereA", Capsule_SphereA, 0}
    ,{"SphereB", Capsule_SphereB, 0}
    ,{"MinimalEnclosingAABB", Capsule_MinimalEnclosingAABB, 0}
    ,{"MinimalEnclosingOBB", Capsule_MinimalEnclosingOBB, 0}
    ,{"Transform", Capsule_Transform_Selector, DUK_VARARGS}
    ,{"Distance", Capsule_Distance_Selector, DUK_VARARGS}
    ,{"Contains", Capsule_Contains_Selector, DUK_VARARGS}
    ,{"Intersects", Capsule_Intersects_Selector, DUK_VARARGS}
    ,{"Equals", Capsule_Equals_Capsule_float, 2}
    ,{"BitEquals", Capsule_BitEquals_Capsule, 1}
    ,{nullptr, nullptr, 0}
};

void Expose_Capsule(duk_context* ctx)
{
    duk_push_c_function(ctx, Capsule_Ctor_Selector, DUK_VARARGS);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, Capsule_Functions);
    DefineProperty(ctx, "r", Capsule_Get_r, Capsule_Set_r);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, Capsule_Id);
}

}
