// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "BindingsHelpers.h"
#include "Geometry/AABB.h"
#include "Geometry/OBB.h"
#include "Geometry/Sphere.h"
#include "Geometry/LineSegment.h"
#include "Geometry/Plane.h"
#include "Algorithm/Random/LCG.h"
#include "Math/float3x3.h"
#include "Math/float3x4.h"
#include "Math/float4x4.h"
#include "Math/Quat.h"
#include "Geometry/Triangle.h"
#include "Geometry/Frustum.h"
#include "Geometry/Capsule.h"
#include "Geometry/Ray.h"
#include "Geometry/Line.h"
#include "Math/float2.h"

using namespace std;

namespace JSBindings
{

extern const char* OBB_Id;
extern const char* Sphere_Id;
extern const char* LineSegment_Id;
extern const char* Plane_Id;
extern const char* LCG_Id;
extern const char* float3x3_Id;
extern const char* float3x4_Id;
extern const char* float4x4_Id;
extern const char* Quat_Id;
extern const char* Triangle_Id;
extern const char* Frustum_Id;
extern const char* Capsule_Id;
extern const char* Ray_Id;
extern const char* Line_Id;
extern const char* float2_Id;

duk_ret_t OBB_Finalizer(duk_context* ctx);
duk_ret_t Sphere_Finalizer(duk_context* ctx);
duk_ret_t LineSegment_Finalizer(duk_context* ctx);
duk_ret_t Plane_Finalizer(duk_context* ctx);
duk_ret_t LCG_Finalizer(duk_context* ctx);
duk_ret_t float3x3_Finalizer(duk_context* ctx);
duk_ret_t float3x4_Finalizer(duk_context* ctx);
duk_ret_t float4x4_Finalizer(duk_context* ctx);
duk_ret_t Quat_Finalizer(duk_context* ctx);
duk_ret_t Triangle_Finalizer(duk_context* ctx);
duk_ret_t Frustum_Finalizer(duk_context* ctx);
duk_ret_t Capsule_Finalizer(duk_context* ctx);
duk_ret_t Ray_Finalizer(duk_context* ctx);
duk_ret_t Line_Finalizer(duk_context* ctx);
duk_ret_t float2_Finalizer(duk_context* ctx);

const char* AABB_Id = "AABB";

duk_ret_t AABB_Finalizer(duk_context* ctx)
{
    AABB* obj = GetValueObject<AABB>(ctx, 0, AABB_Id);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, AABB_Id);
    }
    return 0;
}

static duk_ret_t AABB_Ctor(duk_context* ctx)
{
    AABB* newObj = new AABB();
    PushConstructorResult<AABB>(ctx, newObj, AABB_Id, AABB_Finalizer);
    return 0;
}

static duk_ret_t AABB_Ctor_OBB(duk_context* ctx)
{
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_Id);
    AABB* newObj = new AABB(*obb);
    PushConstructorResult<AABB>(ctx, newObj, AABB_Id, AABB_Finalizer);
    return 0;
}

static duk_ret_t AABB_Ctor_Sphere(duk_context* ctx)
{
    Sphere* s = GetCheckedValueObject<Sphere>(ctx, 0, Sphere_Id);
    AABB* newObj = new AABB(*s);
    PushConstructorResult<AABB>(ctx, newObj, AABB_Id, AABB_Finalizer);
    return 0;
}

static duk_ret_t AABB_MinX(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->MinX();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_MinY(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->MinY();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_MinZ(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->MinZ();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_MaxX(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->MaxX();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_MaxY(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->MaxY();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_MaxZ(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->MaxZ();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_SetNegativeInfinity(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    thisObj->SetNegativeInfinity();
    return 0;
}

static duk_ret_t AABB_SetFrom_OBB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_Id);
    thisObj->SetFrom(*obb);
    return 0;
}

static duk_ret_t AABB_SetFrom_Sphere(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Sphere* s = GetCheckedValueObject<Sphere>(ctx, 0, Sphere_Id);
    thisObj->SetFrom(*s);
    return 0;
}

static duk_ret_t AABB_ToOBB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    OBB ret = thisObj->ToOBB();
    PushValueObjectCopy<OBB>(ctx, ret, OBB_Id, OBB_Finalizer);
    return 1;
}

static duk_ret_t AABB_MinimalEnclosingSphere(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Sphere ret = thisObj->MinimalEnclosingSphere();
    PushValueObjectCopy<Sphere>(ctx, ret, Sphere_Id, Sphere_Finalizer);
    return 1;
}

static duk_ret_t AABB_MaximalContainedSphere(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Sphere ret = thisObj->MaximalContainedSphere();
    PushValueObjectCopy<Sphere>(ctx, ret, Sphere_Id, Sphere_Finalizer);
    return 1;
}

static duk_ret_t AABB_IsFinite(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    bool ret = thisObj->IsFinite();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_IsDegenerate(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    bool ret = thisObj->IsDegenerate();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Edge_int(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    int edgeIndex = (int)duk_require_number(ctx, 0);
    LineSegment ret = thisObj->Edge(edgeIndex);
    PushValueObjectCopy<LineSegment>(ctx, ret, LineSegment_Id, LineSegment_Finalizer);
    return 1;
}

static duk_ret_t AABB_FacePlane_int(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    int faceIndex = (int)duk_require_number(ctx, 0);
    Plane ret = thisObj->FacePlane(faceIndex);
    PushValueObjectCopy<Plane>(ctx, ret, Plane_Id, Plane_Finalizer);
    return 1;
}

static duk_ret_t AABB_Volume(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->Volume();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_SurfaceArea(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float ret = thisObj->SurfaceArea();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_TransformAsAABB_float3x3(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float3x3* transform = GetCheckedValueObject<float3x3>(ctx, 0, float3x3_Id);
    thisObj->TransformAsAABB(*transform);
    return 0;
}

static duk_ret_t AABB_TransformAsAABB_float3x4(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float3x4* transform = GetCheckedValueObject<float3x4>(ctx, 0, float3x4_Id);
    thisObj->TransformAsAABB(*transform);
    return 0;
}

static duk_ret_t AABB_TransformAsAABB_float4x4(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float4x4* transform = GetCheckedValueObject<float4x4>(ctx, 0, float4x4_Id);
    thisObj->TransformAsAABB(*transform);
    return 0;
}

static duk_ret_t AABB_TransformAsAABB_Quat(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Quat* transform = GetCheckedValueObject<Quat>(ctx, 0, Quat_Id);
    thisObj->TransformAsAABB(*transform);
    return 0;
}

static duk_ret_t AABB_Transform_float3x3(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float3x3* transform = GetCheckedValueObject<float3x3>(ctx, 0, float3x3_Id);
    OBB ret = thisObj->Transform(*transform);
    PushValueObjectCopy<OBB>(ctx, ret, OBB_Id, OBB_Finalizer);
    return 1;
}

static duk_ret_t AABB_Transform_float3x4(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float3x4* transform = GetCheckedValueObject<float3x4>(ctx, 0, float3x4_Id);
    OBB ret = thisObj->Transform(*transform);
    PushValueObjectCopy<OBB>(ctx, ret, OBB_Id, OBB_Finalizer);
    return 1;
}

static duk_ret_t AABB_Transform_float4x4(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    float4x4* transform = GetCheckedValueObject<float4x4>(ctx, 0, float4x4_Id);
    OBB ret = thisObj->Transform(*transform);
    PushValueObjectCopy<OBB>(ctx, ret, OBB_Id, OBB_Finalizer);
    return 1;
}

static duk_ret_t AABB_Transform_Quat(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Quat* transform = GetCheckedValueObject<Quat>(ctx, 0, Quat_Id);
    OBB ret = thisObj->Transform(*transform);
    PushValueObjectCopy<OBB>(ctx, ret, OBB_Id, OBB_Finalizer);
    return 1;
}

static duk_ret_t AABB_Distance_Sphere(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Sphere* sphere = GetCheckedValueObject<Sphere>(ctx, 0, Sphere_Id);
    float ret = thisObj->Distance(*sphere);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_LineSegment(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    LineSegment* lineSegment = GetCheckedValueObject<LineSegment>(ctx, 0, LineSegment_Id);
    bool ret = thisObj->Contains(*lineSegment);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_AABB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    AABB* aabb = GetCheckedValueObject<AABB>(ctx, 0, AABB_Id);
    bool ret = thisObj->Contains(*aabb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_OBB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_Id);
    bool ret = thisObj->Contains(*obb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_Sphere(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Sphere* sphere = GetCheckedValueObject<Sphere>(ctx, 0, Sphere_Id);
    bool ret = thisObj->Contains(*sphere);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_Triangle(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Triangle* triangle = GetCheckedValueObject<Triangle>(ctx, 0, Triangle_Id);
    bool ret = thisObj->Contains(*triangle);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_Frustum(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Frustum* frustum = GetCheckedValueObject<Frustum>(ctx, 0, Frustum_Id);
    bool ret = thisObj->Contains(*frustum);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Contains_Capsule(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Capsule* capsule = GetCheckedValueObject<Capsule>(ctx, 0, Capsule_Id);
    bool ret = thisObj->Contains(*capsule);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Ray_float_float(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Ray* ray = GetCheckedValueObject<Ray>(ctx, 0, Ray_Id);
    float dNear = (float)duk_require_number(ctx, 1);
    float dFar = (float)duk_require_number(ctx, 2);
    bool ret = thisObj->Intersects(*ray, dNear, dFar);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Ray(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Ray* ray = GetCheckedValueObject<Ray>(ctx, 0, Ray_Id);
    bool ret = thisObj->Intersects(*ray);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Line_float_float(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Line* line = GetCheckedValueObject<Line>(ctx, 0, Line_Id);
    float dNear = (float)duk_require_number(ctx, 1);
    float dFar = (float)duk_require_number(ctx, 2);
    bool ret = thisObj->Intersects(*line, dNear, dFar);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Line(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Line* line = GetCheckedValueObject<Line>(ctx, 0, Line_Id);
    bool ret = thisObj->Intersects(*line);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_LineSegment_float_float(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    LineSegment* lineSegment = GetCheckedValueObject<LineSegment>(ctx, 0, LineSegment_Id);
    float dNear = (float)duk_require_number(ctx, 1);
    float dFar = (float)duk_require_number(ctx, 2);
    bool ret = thisObj->Intersects(*lineSegment, dNear, dFar);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_LineSegment(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    LineSegment* lineSegment = GetCheckedValueObject<LineSegment>(ctx, 0, LineSegment_Id);
    bool ret = thisObj->Intersects(*lineSegment);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Plane(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Plane* plane = GetCheckedValueObject<Plane>(ctx, 0, Plane_Id);
    bool ret = thisObj->Intersects(*plane);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_AABB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    AABB* aabb = GetCheckedValueObject<AABB>(ctx, 0, AABB_Id);
    bool ret = thisObj->Intersects(*aabb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_OBB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_Id);
    bool ret = thisObj->Intersects(*obb);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Capsule(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Capsule* capsule = GetCheckedValueObject<Capsule>(ctx, 0, Capsule_Id);
    bool ret = thisObj->Intersects(*capsule);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Triangle(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Triangle* triangle = GetCheckedValueObject<Triangle>(ctx, 0, Triangle_Id);
    bool ret = thisObj->Intersects(*triangle);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Intersects_Frustum(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Frustum* frustum = GetCheckedValueObject<Frustum>(ctx, 0, Frustum_Id);
    bool ret = thisObj->Intersects(*frustum);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Enclose_LineSegment(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    LineSegment* lineSegment = GetCheckedValueObject<LineSegment>(ctx, 0, LineSegment_Id);
    thisObj->Enclose(*lineSegment);
    return 0;
}

static duk_ret_t AABB_Enclose_AABB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    AABB* aabb = GetCheckedValueObject<AABB>(ctx, 0, AABB_Id);
    thisObj->Enclose(*aabb);
    return 0;
}

static duk_ret_t AABB_Enclose_OBB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    OBB* obb = GetCheckedValueObject<OBB>(ctx, 0, OBB_Id);
    thisObj->Enclose(*obb);
    return 0;
}

static duk_ret_t AABB_Enclose_Sphere(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Sphere* sphere = GetCheckedValueObject<Sphere>(ctx, 0, Sphere_Id);
    thisObj->Enclose(*sphere);
    return 0;
}

static duk_ret_t AABB_Enclose_Triangle(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Triangle* triangle = GetCheckedValueObject<Triangle>(ctx, 0, Triangle_Id);
    thisObj->Enclose(*triangle);
    return 0;
}

static duk_ret_t AABB_Enclose_Capsule(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Capsule* capsule = GetCheckedValueObject<Capsule>(ctx, 0, Capsule_Id);
    thisObj->Enclose(*capsule);
    return 0;
}

static duk_ret_t AABB_Enclose_Frustum(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    Frustum* frustum = GetCheckedValueObject<Frustum>(ctx, 0, Frustum_Id);
    thisObj->Enclose(*frustum);
    return 0;
}

static duk_ret_t AABB_ToString(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    std::string ret = thisObj->ToString();
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t AABB_SerializeToString(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    std::string ret = thisObj->SerializeToString();
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t AABB_SerializeToCodeString(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    std::string ret = thisObj->SerializeToCodeString();
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t AABB_Intersection_AABB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    AABB* aabb = GetCheckedValueObject<AABB>(ctx, 0, AABB_Id);
    AABB ret = thisObj->Intersection(*aabb);
    PushValueObjectCopy<AABB>(ctx, ret, AABB_Id, AABB_Finalizer);
    return 1;
}

static duk_ret_t AABB_Equals_AABB_float(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    AABB* rhs = GetCheckedValueObject<AABB>(ctx, 0, AABB_Id);
    float epsilon = (float)duk_require_number(ctx, 1);
    bool ret = thisObj->Equals(*rhs, epsilon);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_BitEquals_AABB(duk_context* ctx)
{
    AABB* thisObj = GetThisValueObject<AABB>(ctx, AABB_Id);
    AABB* other = GetCheckedValueObject<AABB>(ctx, 0, AABB_Id);
    bool ret = thisObj->BitEquals(*other);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AABB_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 0)
        return AABB_Ctor(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_Id))
        return AABB_Ctor_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Sphere>(ctx, 0, Sphere_Id))
        return AABB_Ctor_Sphere(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_SetFrom_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_Id))
        return AABB_SetFrom_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Sphere>(ctx, 0, Sphere_Id))
        return AABB_SetFrom_Sphere(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_TransformAsAABB_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<float3x3>(ctx, 0, float3x3_Id))
        return AABB_TransformAsAABB_float3x3(ctx);
    if (numArgs == 1 && GetValueObject<float3x4>(ctx, 0, float3x4_Id))
        return AABB_TransformAsAABB_float3x4(ctx);
    if (numArgs == 1 && GetValueObject<float4x4>(ctx, 0, float4x4_Id))
        return AABB_TransformAsAABB_float4x4(ctx);
    if (numArgs == 1 && GetValueObject<Quat>(ctx, 0, Quat_Id))
        return AABB_TransformAsAABB_Quat(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_Transform_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<float3x3>(ctx, 0, float3x3_Id))
        return AABB_Transform_float3x3(ctx);
    if (numArgs == 1 && GetValueObject<float3x4>(ctx, 0, float3x4_Id))
        return AABB_Transform_float3x4(ctx);
    if (numArgs == 1 && GetValueObject<float4x4>(ctx, 0, float4x4_Id))
        return AABB_Transform_float4x4(ctx);
    if (numArgs == 1 && GetValueObject<Quat>(ctx, 0, Quat_Id))
        return AABB_Transform_Quat(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_Contains_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<LineSegment>(ctx, 0, LineSegment_Id))
        return AABB_Contains_LineSegment(ctx);
    if (numArgs == 1 && GetValueObject<AABB>(ctx, 0, AABB_Id))
        return AABB_Contains_AABB(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_Id))
        return AABB_Contains_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Sphere>(ctx, 0, Sphere_Id))
        return AABB_Contains_Sphere(ctx);
    if (numArgs == 1 && GetValueObject<Triangle>(ctx, 0, Triangle_Id))
        return AABB_Contains_Triangle(ctx);
    if (numArgs == 1 && GetValueObject<Frustum>(ctx, 0, Frustum_Id))
        return AABB_Contains_Frustum(ctx);
    if (numArgs == 1 && GetValueObject<Capsule>(ctx, 0, Capsule_Id))
        return AABB_Contains_Capsule(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_Intersects_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 3 && GetValueObject<Ray>(ctx, 0, Ray_Id) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return AABB_Intersects_Ray_float_float(ctx);
    if (numArgs == 1 && GetValueObject<Ray>(ctx, 0, Ray_Id))
        return AABB_Intersects_Ray(ctx);
    if (numArgs == 3 && GetValueObject<Line>(ctx, 0, Line_Id) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return AABB_Intersects_Line_float_float(ctx);
    if (numArgs == 1 && GetValueObject<Line>(ctx, 0, Line_Id))
        return AABB_Intersects_Line(ctx);
    if (numArgs == 3 && GetValueObject<LineSegment>(ctx, 0, LineSegment_Id) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return AABB_Intersects_LineSegment_float_float(ctx);
    if (numArgs == 1 && GetValueObject<LineSegment>(ctx, 0, LineSegment_Id))
        return AABB_Intersects_LineSegment(ctx);
    if (numArgs == 1 && GetValueObject<Plane>(ctx, 0, Plane_Id))
        return AABB_Intersects_Plane(ctx);
    if (numArgs == 1 && GetValueObject<AABB>(ctx, 0, AABB_Id))
        return AABB_Intersects_AABB(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_Id))
        return AABB_Intersects_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Capsule>(ctx, 0, Capsule_Id))
        return AABB_Intersects_Capsule(ctx);
    if (numArgs == 1 && GetValueObject<Triangle>(ctx, 0, Triangle_Id))
        return AABB_Intersects_Triangle(ctx);
    if (numArgs == 1 && GetValueObject<Frustum>(ctx, 0, Frustum_Id))
        return AABB_Intersects_Frustum(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_Enclose_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && GetValueObject<LineSegment>(ctx, 0, LineSegment_Id))
        return AABB_Enclose_LineSegment(ctx);
    if (numArgs == 1 && GetValueObject<AABB>(ctx, 0, AABB_Id))
        return AABB_Enclose_AABB(ctx);
    if (numArgs == 1 && GetValueObject<OBB>(ctx, 0, OBB_Id))
        return AABB_Enclose_OBB(ctx);
    if (numArgs == 1 && GetValueObject<Sphere>(ctx, 0, Sphere_Id))
        return AABB_Enclose_Sphere(ctx);
    if (numArgs == 1 && GetValueObject<Triangle>(ctx, 0, Triangle_Id))
        return AABB_Enclose_Triangle(ctx);
    if (numArgs == 1 && GetValueObject<Capsule>(ctx, 0, Capsule_Id))
        return AABB_Enclose_Capsule(ctx);
    if (numArgs == 1 && GetValueObject<Frustum>(ctx, 0, Frustum_Id))
        return AABB_Enclose_Frustum(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AABB_NumVerticesInTriangulation_Static_int_int_int(duk_context* ctx)
{
    int numFacesX = (int)duk_require_number(ctx, 0);
    int numFacesY = (int)duk_require_number(ctx, 1);
    int numFacesZ = (int)duk_require_number(ctx, 2);
    int ret = AABB::NumVerticesInTriangulation(numFacesX, numFacesY, numFacesZ);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_NumVerticesInEdgeList_Static(duk_context* ctx)
{
    int ret = AABB::NumVerticesInEdgeList();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AABB_FromString_Static_string(duk_context* ctx)
{
    string str(duk_require_string(ctx, 0));
    AABB ret = AABB::FromString(str);
    PushValueObjectCopy<AABB>(ctx, ret, AABB_Id, AABB_Finalizer);
    return 1;
}

static const duk_function_list_entry AABB_Functions[] = {
    {"MinX", AABB_MinX, 0}
    ,{"MinY", AABB_MinY, 0}
    ,{"MinZ", AABB_MinZ, 0}
    ,{"MaxX", AABB_MaxX, 0}
    ,{"MaxY", AABB_MaxY, 0}
    ,{"MaxZ", AABB_MaxZ, 0}
    ,{"SetNegativeInfinity", AABB_SetNegativeInfinity, 0}
    ,{"SetFrom", AABB_SetFrom_Selector, DUK_VARARGS}
    ,{"ToOBB", AABB_ToOBB, 0}
    ,{"MinimalEnclosingSphere", AABB_MinimalEnclosingSphere, 0}
    ,{"MaximalContainedSphere", AABB_MaximalContainedSphere, 0}
    ,{"IsFinite", AABB_IsFinite, 0}
    ,{"IsDegenerate", AABB_IsDegenerate, 0}
    ,{"Edge", AABB_Edge_int, 1}
    ,{"FacePlane", AABB_FacePlane_int, 1}
    ,{"Volume", AABB_Volume, 0}
    ,{"SurfaceArea", AABB_SurfaceArea, 0}
    ,{"TransformAsAABB", AABB_TransformAsAABB_Selector, DUK_VARARGS}
    ,{"Transform", AABB_Transform_Selector, DUK_VARARGS}
    ,{"Distance", AABB_Distance_Sphere, 1}
    ,{"Contains", AABB_Contains_Selector, DUK_VARARGS}
    ,{"Intersects", AABB_Intersects_Selector, DUK_VARARGS}
    ,{"Enclose", AABB_Enclose_Selector, DUK_VARARGS}
    ,{"ToString", AABB_ToString, 0}
    ,{"SerializeToString", AABB_SerializeToString, 0}
    ,{"SerializeToCodeString", AABB_SerializeToCodeString, 0}
    ,{"Intersection", AABB_Intersection_AABB, 1}
    ,{"Equals", AABB_Equals_AABB_float, 2}
    ,{"BitEquals", AABB_BitEquals_AABB, 1}
    ,{nullptr, nullptr, 0}
};

static const duk_function_list_entry AABB_StaticFunctions[] = {
    {"NumVerticesInTriangulation", AABB_NumVerticesInTriangulation_Static_int_int_int, 3}
    ,{"NumVerticesInEdgeList", AABB_NumVerticesInEdgeList_Static, 0}
    ,{"FromString", AABB_FromString_Static_string, 1}
    ,{nullptr, nullptr, 0}
};

void Expose_AABB(duk_context* ctx)
{
    duk_push_c_function(ctx, AABB_Ctor_Selector, DUK_VARARGS);
    duk_put_function_list(ctx, -1, AABB_StaticFunctions);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, AABB_Functions);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, AABB_Id);
}

}
