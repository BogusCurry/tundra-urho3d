// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Asset/AssetReference.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif



using namespace Tundra;
using namespace std;

namespace JSBindings
{



static const char* AssetReference_ID = "AssetReference";

static duk_ret_t AssetReference_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<AssetReference>(ctx, AssetReference_ID);
    return 0;
}

static duk_ret_t AssetReference_Set_ref(duk_context* ctx)
{
    AssetReference* thisObj = GetThisValueObject<AssetReference>(ctx, AssetReference_ID);
    String ref = duk_require_string(ctx, 0);
    thisObj->ref = ref;
    return 0;
}

static duk_ret_t AssetReference_Get_ref(duk_context* ctx)
{
    AssetReference* thisObj = GetThisValueObject<AssetReference>(ctx, AssetReference_ID);
    duk_push_string(ctx, thisObj->ref.CString());
    return 1;
}

static duk_ret_t AssetReference_Set_type(duk_context* ctx)
{
    AssetReference* thisObj = GetThisValueObject<AssetReference>(ctx, AssetReference_ID);
    String type = duk_require_string(ctx, 0);
    thisObj->type = type;
    return 0;
}

static duk_ret_t AssetReference_Get_type(duk_context* ctx)
{
    AssetReference* thisObj = GetThisValueObject<AssetReference>(ctx, AssetReference_ID);
    duk_push_string(ctx, thisObj->type.CString());
    return 1;
}

static duk_ret_t AssetReference_Ctor(duk_context* ctx)
{
    AssetReference* newObj = new AssetReference();
    PushConstructorResult<AssetReference>(ctx, newObj, AssetReference_ID, AssetReference_Finalizer);
    return 0;
}

static duk_ret_t AssetReference_Ctor_String(duk_context* ctx)
{
    String reference = duk_require_string(ctx, 0);
    AssetReference* newObj = new AssetReference(reference);
    PushConstructorResult<AssetReference>(ctx, newObj, AssetReference_ID, AssetReference_Finalizer);
    return 0;
}

static duk_ret_t AssetReference_Ctor_String_String(duk_context* ctx)
{
    String reference = duk_require_string(ctx, 0);
    String type_ = duk_require_string(ctx, 1);
    AssetReference* newObj = new AssetReference(reference, type_);
    PushConstructorResult<AssetReference>(ctx, newObj, AssetReference_ID, AssetReference_Finalizer);
    return 0;
}

static duk_ret_t AssetReference_ToHash(duk_context* ctx)
{
    AssetReference* thisObj = GetThisValueObject<AssetReference>(ctx, AssetReference_ID);
    unsigned ret = thisObj->ToHash();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AssetReference_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 2 && duk_is_string(ctx, 0) && duk_is_string(ctx, 1))
        return AssetReference_Ctor_String_String(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return AssetReference_Ctor_String(ctx);
    if (numArgs == 0)
        return AssetReference_Ctor(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry AssetReference_Functions[] = {
    {"ToHash", AssetReference_ToHash, 0}
    ,{nullptr, nullptr, 0}
};

void Expose_AssetReference(duk_context* ctx)
{
    duk_push_c_function(ctx, AssetReference_Ctor_Selector, DUK_VARARGS);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, AssetReference_Functions);
    DefineProperty(ctx, "ref", AssetReference_Get_ref, AssetReference_Set_ref);
    DefineProperty(ctx, "type", AssetReference_Get_type, AssetReference_Set_type);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, AssetReference_ID);
}

}
