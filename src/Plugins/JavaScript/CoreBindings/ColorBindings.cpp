// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Math/Color.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif



using namespace Tundra;
using namespace std;

namespace JSBindings
{

static const char* float4_ID = "float4";

static duk_ret_t float4_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<float4>(ctx, float4_ID);
    return 0;
}


static const char* Color_ID = "Color";

static duk_ret_t Color_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<Color>(ctx, Color_ID);
    return 0;
}

static duk_ret_t Color_Set_r(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    float r = (float)duk_require_number(ctx, 0);
    thisObj->r = r;
    return 0;
}

static duk_ret_t Color_Get_r(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    duk_push_number(ctx, thisObj->r);
    return 1;
}

static duk_ret_t Color_Set_g(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    float g = (float)duk_require_number(ctx, 0);
    thisObj->g = g;
    return 0;
}

static duk_ret_t Color_Get_g(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    duk_push_number(ctx, thisObj->g);
    return 1;
}

static duk_ret_t Color_Set_b(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    float b = (float)duk_require_number(ctx, 0);
    thisObj->b = b;
    return 0;
}

static duk_ret_t Color_Get_b(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    duk_push_number(ctx, thisObj->b);
    return 1;
}

static duk_ret_t Color_Set_a(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    float a = (float)duk_require_number(ctx, 0);
    thisObj->a = a;
    return 0;
}

static duk_ret_t Color_Get_a(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    duk_push_number(ctx, thisObj->a);
    return 1;
}

static duk_ret_t Color_Ctor(duk_context* ctx)
{
    Color* newObj = new Color();
    PushConstructorResult<Color>(ctx, newObj, Color_ID, Color_Finalizer);
    return 0;
}

static duk_ret_t Color_Ctor_float_float_float(duk_context* ctx)
{
    float nr = (float)duk_require_number(ctx, 0);
    float ng = (float)duk_require_number(ctx, 1);
    float nb = (float)duk_require_number(ctx, 2);
    Color* newObj = new Color(nr, ng, nb);
    PushConstructorResult<Color>(ctx, newObj, Color_ID, Color_Finalizer);
    return 0;
}

static duk_ret_t Color_Ctor_float_float_float_float(duk_context* ctx)
{
    float nr = (float)duk_require_number(ctx, 0);
    float ng = (float)duk_require_number(ctx, 1);
    float nb = (float)duk_require_number(ctx, 2);
    float na = (float)duk_require_number(ctx, 3);
    Color* newObj = new Color(nr, ng, nb, na);
    PushConstructorResult<Color>(ctx, newObj, Color_ID, Color_Finalizer);
    return 0;
}

static duk_ret_t Color_Ctor_Color(duk_context* ctx)
{
    Color& c = *GetCheckedValueObject<Color>(ctx, 0, Color_ID);
    Color* newObj = new Color(c);
    PushConstructorResult<Color>(ctx, newObj, Color_ID, Color_Finalizer);
    return 0;
}

static duk_ret_t Color_Ctor_float4(duk_context* ctx)
{
    float4& c = *GetCheckedValueObject<float4>(ctx, 0, float4_ID);
    Color* newObj = new Color(c);
    PushConstructorResult<Color>(ctx, newObj, Color_ID, Color_Finalizer);
    return 0;
}

static duk_ret_t Color_Equals_Color_float(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    Color& other = *GetCheckedValueObject<Color>(ctx, 0, Color_ID);
    float epsilon = numArgs > 1 ? (float)duk_require_number(ctx, 1) : 1e-3f;
    bool ret = thisObj->Equals(other, epsilon);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Color_SerializeToString(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    String ret = thisObj->SerializeToString();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t Color_SerializeToCodeString(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    String ret = thisObj->SerializeToCodeString();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t Color_ToString(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    String ret = thisObj->ToString();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t Color_Set_float_float_float(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    float r_ = (float)duk_require_number(ctx, 0);
    float g_ = (float)duk_require_number(ctx, 1);
    float b_ = (float)duk_require_number(ctx, 2);
    thisObj->Set(r_, g_, b_);
    return 0;
}

static duk_ret_t Color_ToFloat4(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    float4 ret = thisObj->ToFloat4();
    PushValueObjectCopy<float4>(ctx, ret, float4_ID, float4_Finalizer);
    return 1;
}

static duk_ret_t Color_ToUrhoColor(duk_context* ctx)
{
    Color* thisObj = GetThisValueObject<Color>(ctx, Color_ID);
    Color ret = thisObj->ToUrhoColor();
    PushValueObjectCopy<Color>(ctx, ret, Color_ID, Color_Finalizer);
    return 1;
}

static duk_ret_t Color_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 4 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2) && duk_is_number(ctx, 3))
        return Color_Ctor_float_float_float_float(ctx);
    if (numArgs == 3 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1) && duk_is_number(ctx, 2))
        return Color_Ctor_float_float_float(ctx);
    if (numArgs == 1 && GetValueObject<Color>(ctx, 0, Color_ID))
        return Color_Ctor_Color(ctx);
    if (numArgs == 1 && GetValueObject<float4>(ctx, 0, float4_ID))
        return Color_Ctor_float4(ctx);
    if (numArgs == 0)
        return Color_Ctor(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry Color_Functions[] = {
    {"Equals", Color_Equals_Color_float, DUK_VARARGS}
    ,{"SerializeToString", Color_SerializeToString, 0}
    ,{"SerializeToCodeString", Color_SerializeToCodeString, 0}
    ,{"ToString", Color_ToString, 0}
    ,{"Set", Color_Set_float_float_float, 3}
    ,{"ToFloat4", Color_ToFloat4, 0}
    ,{"ToUrhoColor", Color_ToUrhoColor, 0}
    ,{nullptr, nullptr, 0}
};

void Expose_Color(duk_context* ctx)
{
    duk_push_c_function(ctx, Color_Ctor_Selector, DUK_VARARGS);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, Color_Functions);
    DefineProperty(ctx, "r", Color_Get_r, Color_Set_r);
    DefineProperty(ctx, "g", Color_Get_g, Color_Set_g);
    DefineProperty(ctx, "b", Color_Get_b, Color_Set_b);
    DefineProperty(ctx, "a", Color_Get_a, Color_Set_a);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, Color_ID);
    duk_get_global_string(ctx, Color_ID);
    PushValueObjectCopy<Color>(ctx, Color::Red, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Red");
    PushValueObjectCopy<Color>(ctx, Color::Green, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Green");
    PushValueObjectCopy<Color>(ctx, Color::Blue, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Blue");
    PushValueObjectCopy<Color>(ctx, Color::White, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "White");
    PushValueObjectCopy<Color>(ctx, Color::Black, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Black");
    PushValueObjectCopy<Color>(ctx, Color::Yellow, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Yellow");
    PushValueObjectCopy<Color>(ctx, Color::Cyan, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Cyan");
    PushValueObjectCopy<Color>(ctx, Color::Magenta, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Magenta");
    PushValueObjectCopy<Color>(ctx, Color::Gray, Color_ID, Color_Finalizer);
    duk_put_prop_string(ctx, -2, "Gray");
    duk_pop(ctx);
}

}
