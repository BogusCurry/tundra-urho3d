// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Asset/AssetAPI.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif

#include "Framework/Framework.h"


using namespace Tundra;
using namespace std;

namespace JSBindings
{



const char* AssetAPI_ID = "AssetAPI";

const char* SignalWrapper_AssetAPI_AssetCreated_ID = "SignalWrapper_AssetAPI_AssetCreated";

class SignalWrapper_AssetAPI_AssetCreated
{
public:
    SignalWrapper_AssetAPI_AssetCreated(Object* owner, Signal1< AssetPtr >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< AssetPtr >* signal_;
};

class SignalReceiver_AssetAPI_AssetCreated : public SignalReceiver
{
public:
    void OnSignal(AssetPtr param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

duk_ret_t SignalWrapper_AssetAPI_AssetCreated_Finalizer(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetCreated* obj = GetValueObject<SignalWrapper_AssetAPI_AssetCreated>(ctx, 0, SignalWrapper_AssetAPI_AssetCreated_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, SignalWrapper_AssetAPI_AssetCreated_ID);
    }
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetCreated_Connect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetCreated* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetCreated>(ctx, SignalWrapper_AssetAPI_AssetCreated_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_AssetAPI_AssetCreated* receiver = new SignalReceiver_AssetAPI_AssetCreated();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_AssetAPI_AssetCreated::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_ConnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetCreated_Disconnect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetCreated* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetCreated>(ctx, SignalWrapper_AssetAPI_AssetCreated_ID);
    if (!wrapper->owner_) return 0;
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_DisconnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    if (duk_get_boolean(ctx, -1))
    {
        HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
        signalReceivers.Erase(wrapper->signal_);
    }
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetCreated_Emit(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetCreated* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetCreated>(ctx, SignalWrapper_AssetAPI_AssetCreated_ID);
    if (!wrapper->owner_) return 0;
    SharedPtr<IAsset> param0(GetWeakObject<IAsset>(ctx, 0));
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t AssetAPI_Get_AssetCreated(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SignalWrapper_AssetAPI_AssetCreated* wrapper = new SignalWrapper_AssetAPI_AssetCreated(thisObj, &thisObj->AssetCreated);
    PushValueObject(ctx, wrapper, SignalWrapper_AssetAPI_AssetCreated_ID, SignalWrapper_AssetAPI_AssetCreated_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetCreated_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetCreated_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetCreated_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID = "SignalWrapper_AssetAPI_AssetAboutToBeRemoved";

class SignalWrapper_AssetAPI_AssetAboutToBeRemoved
{
public:
    SignalWrapper_AssetAPI_AssetAboutToBeRemoved(Object* owner, Signal1< AssetPtr >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< AssetPtr >* signal_;
};

class SignalReceiver_AssetAPI_AssetAboutToBeRemoved : public SignalReceiver
{
public:
    void OnSignal(AssetPtr param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

duk_ret_t SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Finalizer(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetAboutToBeRemoved* obj = GetValueObject<SignalWrapper_AssetAPI_AssetAboutToBeRemoved>(ctx, 0, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID);
    }
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Connect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetAboutToBeRemoved* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetAboutToBeRemoved>(ctx, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_AssetAPI_AssetAboutToBeRemoved* receiver = new SignalReceiver_AssetAPI_AssetAboutToBeRemoved();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_AssetAPI_AssetAboutToBeRemoved::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_ConnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Disconnect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetAboutToBeRemoved* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetAboutToBeRemoved>(ctx, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID);
    if (!wrapper->owner_) return 0;
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_DisconnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    if (duk_get_boolean(ctx, -1))
    {
        HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
        signalReceivers.Erase(wrapper->signal_);
    }
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Emit(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetAboutToBeRemoved* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetAboutToBeRemoved>(ctx, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID);
    if (!wrapper->owner_) return 0;
    SharedPtr<IAsset> param0(GetWeakObject<IAsset>(ctx, 0));
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t AssetAPI_Get_AssetAboutToBeRemoved(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SignalWrapper_AssetAPI_AssetAboutToBeRemoved* wrapper = new SignalWrapper_AssetAPI_AssetAboutToBeRemoved(thisObj, &thisObj->AssetAboutToBeRemoved);
    PushValueObject(ctx, wrapper, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_ID, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetAboutToBeRemoved_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID = "SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved";

class SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved
{
public:
    SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved(Object* owner, Signal1< AssetPtr >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< AssetPtr >* signal_;
};

class SignalReceiver_AssetAPI_DiskSourceAboutToBeRemoved : public SignalReceiver
{
public:
    void OnSignal(AssetPtr param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

duk_ret_t SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Finalizer(duk_context* ctx)
{
    SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved* obj = GetValueObject<SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved>(ctx, 0, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID);
    }
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Connect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved>(ctx, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_AssetAPI_DiskSourceAboutToBeRemoved* receiver = new SignalReceiver_AssetAPI_DiskSourceAboutToBeRemoved();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_AssetAPI_DiskSourceAboutToBeRemoved::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_ConnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Disconnect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved>(ctx, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID);
    if (!wrapper->owner_) return 0;
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_DisconnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    if (duk_get_boolean(ctx, -1))
    {
        HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
        signalReceivers.Erase(wrapper->signal_);
    }
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Emit(duk_context* ctx)
{
    SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved>(ctx, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID);
    if (!wrapper->owner_) return 0;
    SharedPtr<IAsset> param0(GetWeakObject<IAsset>(ctx, 0));
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t AssetAPI_Get_DiskSourceAboutToBeRemoved(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved* wrapper = new SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved(thisObj, &thisObj->DiskSourceAboutToBeRemoved);
    PushValueObject(ctx, wrapper, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_ID, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_DiskSourceAboutToBeRemoved_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID = "SignalWrapper_AssetAPI_AssetDiskSourceChanged";

class SignalWrapper_AssetAPI_AssetDiskSourceChanged
{
public:
    SignalWrapper_AssetAPI_AssetDiskSourceChanged(Object* owner, Signal1< AssetPtr >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< AssetPtr >* signal_;
};

class SignalReceiver_AssetAPI_AssetDiskSourceChanged : public SignalReceiver
{
public:
    void OnSignal(AssetPtr param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        PushWeakObject(ctx, param0);
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

duk_ret_t SignalWrapper_AssetAPI_AssetDiskSourceChanged_Finalizer(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDiskSourceChanged* obj = GetValueObject<SignalWrapper_AssetAPI_AssetDiskSourceChanged>(ctx, 0, SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID);
    }
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetDiskSourceChanged_Connect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDiskSourceChanged* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetDiskSourceChanged>(ctx, SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_AssetAPI_AssetDiskSourceChanged* receiver = new SignalReceiver_AssetAPI_AssetDiskSourceChanged();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_AssetAPI_AssetDiskSourceChanged::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_ConnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetDiskSourceChanged_Disconnect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDiskSourceChanged* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetDiskSourceChanged>(ctx, SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID);
    if (!wrapper->owner_) return 0;
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_DisconnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    if (duk_get_boolean(ctx, -1))
    {
        HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
        signalReceivers.Erase(wrapper->signal_);
    }
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetDiskSourceChanged_Emit(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDiskSourceChanged* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetDiskSourceChanged>(ctx, SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID);
    if (!wrapper->owner_) return 0;
    SharedPtr<IAsset> param0(GetWeakObject<IAsset>(ctx, 0));
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t AssetAPI_Get_AssetDiskSourceChanged(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SignalWrapper_AssetAPI_AssetDiskSourceChanged* wrapper = new SignalWrapper_AssetAPI_AssetDiskSourceChanged(thisObj, &thisObj->AssetDiskSourceChanged);
    PushValueObject(ctx, wrapper, SignalWrapper_AssetAPI_AssetDiskSourceChanged_ID, SignalWrapper_AssetAPI_AssetDiskSourceChanged_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetDiskSourceChanged_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetDiskSourceChanged_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetDiskSourceChanged_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_AssetAPI_AssetUploaded_ID = "SignalWrapper_AssetAPI_AssetUploaded";

class SignalWrapper_AssetAPI_AssetUploaded
{
public:
    SignalWrapper_AssetAPI_AssetUploaded(Object* owner, Signal1< const String & >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< const String & >* signal_;
};

class SignalReceiver_AssetAPI_AssetUploaded : public SignalReceiver
{
public:
    void OnSignal(const String & param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        duk_push_string(ctx, param0.CString());
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

duk_ret_t SignalWrapper_AssetAPI_AssetUploaded_Finalizer(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetUploaded* obj = GetValueObject<SignalWrapper_AssetAPI_AssetUploaded>(ctx, 0, SignalWrapper_AssetAPI_AssetUploaded_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, SignalWrapper_AssetAPI_AssetUploaded_ID);
    }
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetUploaded_Connect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetUploaded* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetUploaded>(ctx, SignalWrapper_AssetAPI_AssetUploaded_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_AssetAPI_AssetUploaded* receiver = new SignalReceiver_AssetAPI_AssetUploaded();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_AssetAPI_AssetUploaded::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_ConnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetUploaded_Disconnect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetUploaded* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetUploaded>(ctx, SignalWrapper_AssetAPI_AssetUploaded_ID);
    if (!wrapper->owner_) return 0;
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_DisconnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    if (duk_get_boolean(ctx, -1))
    {
        HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
        signalReceivers.Erase(wrapper->signal_);
    }
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetUploaded_Emit(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetUploaded* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetUploaded>(ctx, SignalWrapper_AssetAPI_AssetUploaded_ID);
    if (!wrapper->owner_) return 0;
    String param0(duk_require_string(ctx, 0));
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t AssetAPI_Get_AssetUploaded(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SignalWrapper_AssetAPI_AssetUploaded* wrapper = new SignalWrapper_AssetAPI_AssetUploaded(thisObj, &thisObj->AssetUploaded);
    PushValueObject(ctx, wrapper, SignalWrapper_AssetAPI_AssetUploaded_ID, SignalWrapper_AssetAPI_AssetUploaded_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetUploaded_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetUploaded_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetUploaded_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID = "SignalWrapper_AssetAPI_AssetDeletedFromStorage";

class SignalWrapper_AssetAPI_AssetDeletedFromStorage
{
public:
    SignalWrapper_AssetAPI_AssetDeletedFromStorage(Object* owner, Signal1< const String & >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< const String & >* signal_;
};

class SignalReceiver_AssetAPI_AssetDeletedFromStorage : public SignalReceiver
{
public:
    void OnSignal(const String & param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        duk_push_string(ctx, param0.CString());
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

duk_ret_t SignalWrapper_AssetAPI_AssetDeletedFromStorage_Finalizer(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDeletedFromStorage* obj = GetValueObject<SignalWrapper_AssetAPI_AssetDeletedFromStorage>(ctx, 0, SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID);
    }
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetDeletedFromStorage_Connect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDeletedFromStorage* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetDeletedFromStorage>(ctx, SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_AssetAPI_AssetDeletedFromStorage* receiver = new SignalReceiver_AssetAPI_AssetDeletedFromStorage();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_AssetAPI_AssetDeletedFromStorage::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_ConnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetDeletedFromStorage_Disconnect(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDeletedFromStorage* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetDeletedFromStorage>(ctx, SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID);
    if (!wrapper->owner_) return 0;
    int numArgs = duk_get_top(ctx);
    duk_push_number(ctx, (size_t)wrapper->signal_);
    duk_insert(ctx, 0);
    duk_push_global_object(ctx);
    duk_get_prop_string(ctx, -1, "_DisconnectSignal");
    duk_remove(ctx, -2);
    duk_insert(ctx, 0);
    duk_pcall(ctx, numArgs + 1);
    if (duk_get_boolean(ctx, -1))
    {
        HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
        signalReceivers.Erase(wrapper->signal_);
    }
    duk_pop(ctx);
    return 0;
}

static duk_ret_t SignalWrapper_AssetAPI_AssetDeletedFromStorage_Emit(duk_context* ctx)
{
    SignalWrapper_AssetAPI_AssetDeletedFromStorage* wrapper = GetThisValueObject<SignalWrapper_AssetAPI_AssetDeletedFromStorage>(ctx, SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID);
    if (!wrapper->owner_) return 0;
    String param0(duk_require_string(ctx, 0));
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t AssetAPI_Get_AssetDeletedFromStorage(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SignalWrapper_AssetAPI_AssetDeletedFromStorage* wrapper = new SignalWrapper_AssetAPI_AssetDeletedFromStorage(thisObj, &thisObj->AssetDeletedFromStorage);
    PushValueObject(ctx, wrapper, SignalWrapper_AssetAPI_AssetDeletedFromStorage_ID, SignalWrapper_AssetAPI_AssetDeletedFromStorage_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetDeletedFromStorage_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetDeletedFromStorage_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_AssetAPI_AssetDeletedFromStorage_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

static duk_ret_t AssetAPI_Update_float(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    float frametime = (float)duk_require_number(ctx, 0);
    thisObj->Update(frametime);
    return 0;
}

static duk_ret_t AssetAPI_AssetLoadCompleted_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    thisObj->AssetLoadCompleted(assetRef);
    return 0;
}

static duk_ret_t AssetAPI_AssetLoadFailed_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    thisObj->AssetLoadFailed(assetRef);
    return 0;
}

static duk_ret_t AssetAPI_NotifyAssetDependenciesChanged_AssetPtr(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SharedPtr<IAsset> asset(GetWeakObject<IAsset>(ctx, 0));
    thisObj->NotifyAssetDependenciesChanged(asset);
    return 0;
}

static duk_ret_t AssetAPI_IsHeadless(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    bool ret = thisObj->IsHeadless();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_GetFramework(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    Framework * ret = thisObj->GetFramework();
    PushWeakObject(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_Assets(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    AssetMap ret = thisObj->Assets();
    PushWeakObjectMap(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_AssetsOfType_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String type(duk_require_string(ctx, 0));
    AssetMap ret = thisObj->AssetsOfType(type);
    PushWeakObjectMap(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_OpenAssetCache_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String directory(duk_require_string(ctx, 0));
    thisObj->OpenAssetCache(directory);
    return 0;
}

static duk_ret_t AssetAPI_CreateNewAsset_String_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String type(duk_require_string(ctx, 0));
    String name(duk_require_string(ctx, 1));
    AssetPtr ret = thisObj->CreateNewAsset(type, name);
    PushWeakObject(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_CreateAssetFromFile_String_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetType(duk_require_string(ctx, 0));
    String assetFile(duk_require_string(ctx, 1));
    AssetPtr ret = thisObj->CreateAssetFromFile(assetType, assetFile);
    PushWeakObject(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_GenerateUniqueAssetName_String_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetTypePrefix(duk_require_string(ctx, 0));
    String assetNamePrefix(duk_require_string(ctx, 1));
    String ret = thisObj->GenerateUniqueAssetName(assetTypePrefix, assetNamePrefix);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_GenerateTemporaryNonexistingAssetFilename_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String filename(duk_require_string(ctx, 0));
    String ret = thisObj->GenerateTemporaryNonexistingAssetFilename(filename);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_FindAsset_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    AssetPtr ret = thisObj->FindAsset(assetRef);
    PushWeakObject(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_RemoveAssetStorage_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String name(duk_require_string(ctx, 0));
    bool ret = thisObj->RemoveAssetStorage(name);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_ResourceTypeForAssetRef_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    String ret = thisObj->ResourceTypeForAssetRef(assetRef);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_ResolveAssetRef_String_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String context(duk_require_string(ctx, 0));
    String ref(duk_require_string(ctx, 1));
    String ret = thisObj->ResolveAssetRef(context, ref);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_ForgetAsset_AssetPtr_bool(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SharedPtr<IAsset> asset(GetWeakObject<IAsset>(ctx, 0));
    bool removeDiskSource = duk_require_boolean(ctx, 1);
    bool ret = thisObj->ForgetAsset(asset, removeDiskSource);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_ForgetAsset_String_bool(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    bool removeDiskSource = duk_require_boolean(ctx, 1);
    bool ret = thisObj->ForgetAsset(assetRef, removeDiskSource);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_ForgetBundle_String_bool(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String bundleRef(duk_require_string(ctx, 0));
    bool removeDiskSource = duk_require_boolean(ctx, 1);
    bool ret = thisObj->ForgetBundle(bundleRef, removeDiskSource);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_DeleteAssetFromStorage_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    thisObj->DeleteAssetFromStorage(assetRef);
    return 0;
}

static duk_ret_t AssetAPI_ForgetAllAssets(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    thisObj->ForgetAllAssets();
    return 0;
}

static duk_ret_t AssetAPI_RequestAssetDependencies_AssetPtr(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SharedPtr<IAsset> transfer(GetWeakObject<IAsset>(ctx, 0));
    thisObj->RequestAssetDependencies(transfer);
    return 0;
}

static duk_ret_t AssetAPI_NumPendingDependencies_AssetPtr(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SharedPtr<IAsset> asset(GetWeakObject<IAsset>(ctx, 0));
    int ret = thisObj->NumPendingDependencies(asset);
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_HasPendingDependencies_AssetPtr(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    SharedPtr<IAsset> asset(GetWeakObject<IAsset>(ctx, 0));
    bool ret = thisObj->HasPendingDependencies(asset);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetAPI_HandleAssetDiscovery_String_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    String assetType(duk_require_string(ctx, 1));
    thisObj->HandleAssetDiscovery(assetRef, assetType);
    return 0;
}

static duk_ret_t AssetAPI_HandleAssetDeleted_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    thisObj->HandleAssetDeleted(assetRef);
    return 0;
}

static duk_ret_t AssetAPI_EmitAssetDeletedFromStorage_String(duk_context* ctx)
{
    AssetAPI* thisObj = GetThisWeakObject<AssetAPI>(ctx);
    String assetRef(duk_require_string(ctx, 0));
    thisObj->EmitAssetDeletedFromStorage(assetRef);
    return 0;
}

static duk_ret_t AssetAPI_ForgetAsset_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 2 && duk_is_boolean(ctx, 1))
        return AssetAPI_ForgetAsset_AssetPtr_bool(ctx);
    if (numArgs == 2 && duk_is_string(ctx, 0) && duk_is_boolean(ctx, 1))
        return AssetAPI_ForgetAsset_String_bool(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AssetAPI_SanitateAssetRef_Static_String(duk_context* ctx)
{
    String ref(duk_require_string(ctx, 0));
    String ret = AssetAPI::SanitateAssetRef(ref);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_SanitateAssetRef_Static_string(duk_context* ctx)
{
    string ref(duk_require_string(ctx, 0));
    string ret = AssetAPI::SanitateAssetRef(ref);
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t AssetAPI_DesanitateAssetRef_Static_String(duk_context* ctx)
{
    String ref(duk_require_string(ctx, 0));
    String ret = AssetAPI::DesanitateAssetRef(ref);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_DesanitateAssetRef_Static_string(duk_context* ctx)
{
    string ref(duk_require_string(ctx, 0));
    string ret = AssetAPI::DesanitateAssetRef(ref);
    duk_push_string(ctx, ret.c_str());
    return 1;
}

static duk_ret_t AssetAPI_ExtractFilenameFromAssetRef_Static_String(duk_context* ctx)
{
    String ref(duk_require_string(ctx, 0));
    String ret = AssetAPI::ExtractFilenameFromAssetRef(ref);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_RecursiveFindFile_Static_String_String(duk_context* ctx)
{
    String basePath(duk_require_string(ctx, 0));
    String filename(duk_require_string(ctx, 1));
    String ret = AssetAPI::RecursiveFindFile(basePath, filename);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t AssetAPI_SanitateAssetRef_Static_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return AssetAPI_SanitateAssetRef_Static_String(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return AssetAPI_SanitateAssetRef_Static_string(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t AssetAPI_DesanitateAssetRef_Static_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return AssetAPI_DesanitateAssetRef_Static_String(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return AssetAPI_DesanitateAssetRef_Static_string(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry AssetAPI_Functions[] = {
    {"Update", AssetAPI_Update_float, 1}
    ,{"AssetLoadCompleted", AssetAPI_AssetLoadCompleted_String, 1}
    ,{"AssetLoadFailed", AssetAPI_AssetLoadFailed_String, 1}
    ,{"NotifyAssetDependenciesChanged", AssetAPI_NotifyAssetDependenciesChanged_AssetPtr, 1}
    ,{"IsHeadless", AssetAPI_IsHeadless, 0}
    ,{"GetFramework", AssetAPI_GetFramework, 0}
    ,{"Assets", AssetAPI_Assets, 0}
    ,{"AssetsOfType", AssetAPI_AssetsOfType_String, 1}
    ,{"OpenAssetCache", AssetAPI_OpenAssetCache_String, 1}
    ,{"CreateNewAsset", AssetAPI_CreateNewAsset_String_String, 2}
    ,{"CreateAssetFromFile", AssetAPI_CreateAssetFromFile_String_String, 2}
    ,{"GenerateUniqueAssetName", AssetAPI_GenerateUniqueAssetName_String_String, 2}
    ,{"GenerateTemporaryNonexistingAssetFilename", AssetAPI_GenerateTemporaryNonexistingAssetFilename_String, 1}
    ,{"FindAsset", AssetAPI_FindAsset_String, 1}
    ,{"RemoveAssetStorage", AssetAPI_RemoveAssetStorage_String, 1}
    ,{"ResourceTypeForAssetRef", AssetAPI_ResourceTypeForAssetRef_String, 1}
    ,{"ResolveAssetRef", AssetAPI_ResolveAssetRef_String_String, 2}
    ,{"ForgetAsset", AssetAPI_ForgetAsset_Selector, DUK_VARARGS}
    ,{"ForgetBundle", AssetAPI_ForgetBundle_String_bool, 2}
    ,{"DeleteAssetFromStorage", AssetAPI_DeleteAssetFromStorage_String, 1}
    ,{"ForgetAllAssets", AssetAPI_ForgetAllAssets, 0}
    ,{"RequestAssetDependencies", AssetAPI_RequestAssetDependencies_AssetPtr, 1}
    ,{"NumPendingDependencies", AssetAPI_NumPendingDependencies_AssetPtr, 1}
    ,{"HasPendingDependencies", AssetAPI_HasPendingDependencies_AssetPtr, 1}
    ,{"HandleAssetDiscovery", AssetAPI_HandleAssetDiscovery_String_String, 2}
    ,{"HandleAssetDeleted", AssetAPI_HandleAssetDeleted_String, 1}
    ,{"EmitAssetDeletedFromStorage", AssetAPI_EmitAssetDeletedFromStorage_String, 1}
    ,{nullptr, nullptr, 0}
};

static const duk_function_list_entry AssetAPI_StaticFunctions[] = {
    {"SanitateAssetRef", AssetAPI_SanitateAssetRef_Static_Selector, DUK_VARARGS}
    ,{"DesanitateAssetRef", AssetAPI_DesanitateAssetRef_Static_Selector, DUK_VARARGS}
    ,{"ExtractFilenameFromAssetRef", AssetAPI_ExtractFilenameFromAssetRef_Static_String, 1}
    ,{"RecursiveFindFile", AssetAPI_RecursiveFindFile_Static_String_String, 2}
    ,{nullptr, nullptr, 0}
};

void Expose_AssetAPI(duk_context* ctx)
{
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, AssetAPI_StaticFunctions);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, AssetAPI_Functions);
    DefineProperty(ctx, "assetCreated", AssetAPI_Get_AssetCreated, nullptr);
    DefineProperty(ctx, "assetAboutToBeRemoved", AssetAPI_Get_AssetAboutToBeRemoved, nullptr);
    DefineProperty(ctx, "diskSourceAboutToBeRemoved", AssetAPI_Get_DiskSourceAboutToBeRemoved, nullptr);
    DefineProperty(ctx, "assetDiskSourceChanged", AssetAPI_Get_AssetDiskSourceChanged, nullptr);
    DefineProperty(ctx, "assetUploaded", AssetAPI_Get_AssetUploaded, nullptr);
    DefineProperty(ctx, "assetDeletedFromStorage", AssetAPI_Get_AssetDeletedFromStorage, nullptr);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, AssetAPI_ID);
}

}
