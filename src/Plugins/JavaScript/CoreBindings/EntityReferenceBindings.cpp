// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Scene/EntityReference.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif

#include "Scene/Entity.h"
#include "Scene/Scene.h"


using namespace Tundra;
using namespace std;

namespace JSBindings
{



static const char* EntityReference_ID = "EntityReference";

static duk_ret_t EntityReference_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<EntityReference>(ctx, EntityReference_ID);
    return 0;
}

static duk_ret_t EntityReference_Set_ref(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    String ref = duk_require_string(ctx, 0);
    thisObj->ref = ref;
    return 0;
}

static duk_ret_t EntityReference_Get_ref(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    duk_push_string(ctx, thisObj->ref.CString());
    return 1;
}

static duk_ret_t EntityReference_Ctor(duk_context* ctx)
{
    EntityReference* newObj = new EntityReference();
    PushConstructorResult<EntityReference>(ctx, newObj, EntityReference_ID, EntityReference_Finalizer);
    return 0;
}

static duk_ret_t EntityReference_Ctor_String(duk_context* ctx)
{
    String entityName = duk_require_string(ctx, 0);
    EntityReference* newObj = new EntityReference(entityName);
    PushConstructorResult<EntityReference>(ctx, newObj, EntityReference_ID, EntityReference_Finalizer);
    return 0;
}

static duk_ret_t EntityReference_Ctor_entity_id_t(duk_context* ctx)
{
    entity_id_t id = (entity_id_t)duk_require_number(ctx, 0);
    EntityReference* newObj = new EntityReference(id);
    PushConstructorResult<EntityReference>(ctx, newObj, EntityReference_ID, EntityReference_Finalizer);
    return 0;
}

static duk_ret_t EntityReference_Set_EntityPtr(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    SharedPtr<Entity> entity(GetWeakObject<Entity>(ctx, 0));
    thisObj->Set(entity);
    return 0;
}

static duk_ret_t EntityReference_Set_Entity(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    Entity* entity = GetWeakObject<Entity>(ctx, 0);
    thisObj->Set(entity);
    return 0;
}

static duk_ret_t EntityReference_Lookup_Scene(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    Scene* scene = GetWeakObject<Scene>(ctx, 0);
    EntityPtr ret = thisObj->Lookup(scene);
    PushWeakObject(ctx, ret.Get());
    return 1;
}

static duk_ret_t EntityReference_LookupParent_Entity(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    Entity* entity = GetWeakObject<Entity>(ctx, 0);
    EntityPtr ret = thisObj->LookupParent(entity);
    PushWeakObject(ctx, ret.Get());
    return 1;
}

static duk_ret_t EntityReference_Matches_Entity(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    Entity* entity = GetWeakObject<Entity>(ctx, 0);
    bool ret = thisObj->Matches(entity);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t EntityReference_IsEmpty(duk_context* ctx)
{
    EntityReference* thisObj = GetThisValueObject<EntityReference>(ctx, EntityReference_ID);
    bool ret = thisObj->IsEmpty();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t EntityReference_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1 && duk_is_number(ctx, 0))
        return EntityReference_Ctor_entity_id_t(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return EntityReference_Ctor_String(ctx);
    if (numArgs == 0)
        return EntityReference_Ctor(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static duk_ret_t EntityReference_Set_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 1)
        return EntityReference_Set_Entity(ctx);
    if (numArgs == 1)
        return EntityReference_Set_EntityPtr(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry EntityReference_Functions[] = {
    {"Set", EntityReference_Set_Selector, DUK_VARARGS}
    ,{"Lookup", EntityReference_Lookup_Scene, 1}
    ,{"LookupParent", EntityReference_LookupParent_Entity, 1}
    ,{"Matches", EntityReference_Matches_Entity, 1}
    ,{"IsEmpty", EntityReference_IsEmpty, 0}
    ,{nullptr, nullptr, 0}
};

void Expose_EntityReference(duk_context* ctx)
{
    duk_push_c_function(ctx, EntityReference_Ctor_Selector, DUK_VARARGS);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, EntityReference_Functions);
    DefineProperty(ctx, "ref", EntityReference_Get_ref, EntityReference_Set_ref);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, EntityReference_ID);
}

}
