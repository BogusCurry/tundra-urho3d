// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Math/Point.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif



using namespace Tundra;
using namespace std;

namespace JSBindings
{



static const char* Point_ID = "Point";

static duk_ret_t Point_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<Point>(ctx, Point_ID);
    return 0;
}

static duk_ret_t Point_Set_x(duk_context* ctx)
{
    Point* thisObj = GetThisValueObject<Point>(ctx, Point_ID);
    int x = (int)duk_require_number(ctx, 0);
    thisObj->x = x;
    return 0;
}

static duk_ret_t Point_Get_x(duk_context* ctx)
{
    Point* thisObj = GetThisValueObject<Point>(ctx, Point_ID);
    duk_push_number(ctx, thisObj->x);
    return 1;
}

static duk_ret_t Point_Set_y(duk_context* ctx)
{
    Point* thisObj = GetThisValueObject<Point>(ctx, Point_ID);
    int y = (int)duk_require_number(ctx, 0);
    thisObj->y = y;
    return 0;
}

static duk_ret_t Point_Get_y(duk_context* ctx)
{
    Point* thisObj = GetThisValueObject<Point>(ctx, Point_ID);
    duk_push_number(ctx, thisObj->y);
    return 1;
}

static duk_ret_t Point_Ctor(duk_context* ctx)
{
    Point* newObj = new Point();
    PushConstructorResult<Point>(ctx, newObj, Point_ID, Point_Finalizer);
    return 0;
}

static duk_ret_t Point_Ctor_int_int(duk_context* ctx)
{
    int nx = (int)duk_require_number(ctx, 0);
    int ny = (int)duk_require_number(ctx, 1);
    Point* newObj = new Point(nx, ny);
    PushConstructorResult<Point>(ctx, newObj, Point_ID, Point_Finalizer);
    return 0;
}

static duk_ret_t Point_SerializeToString(duk_context* ctx)
{
    Point* thisObj = GetThisValueObject<Point>(ctx, Point_ID);
    String ret = thisObj->SerializeToString();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t Point_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 2 && duk_is_number(ctx, 0) && duk_is_number(ctx, 1))
        return Point_Ctor_int_int(ctx);
    if (numArgs == 0)
        return Point_Ctor(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry Point_Functions[] = {
    {"SerializeToString", Point_SerializeToString, 0}
    ,{nullptr, nullptr, 0}
};

void Expose_Point(duk_context* ctx)
{
    duk_push_c_function(ctx, Point_Ctor_Selector, DUK_VARARGS);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, Point_Functions);
    DefineProperty(ctx, "x", Point_Get_x, Point_Set_x);
    DefineProperty(ctx, "y", Point_Get_y, Point_Set_y);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, Point_ID);
}

}
