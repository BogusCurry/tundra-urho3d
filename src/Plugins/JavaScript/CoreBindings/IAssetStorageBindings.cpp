// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Asset/IAssetStorage.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif



using namespace Tundra;
using namespace std;

namespace JSBindings
{



static const char* IAssetStorage_ID = "IAssetStorage";

static duk_ret_t IAssetStorage_SetReplicated_bool(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool isReplicated_ = duk_require_boolean(ctx, 0);
    thisObj->SetReplicated(isReplicated_);
    return 0;
}

static duk_ret_t IAssetStorage_GetAllAssetRefs(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    StringVector ret = thisObj->GetAllAssetRefs();
    PushStringVector(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_RefreshAssetRefs(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    thisObj->RefreshAssetRefs();
    return 0;
}

static duk_ret_t IAssetStorage_Writable(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool ret = thisObj->Writable();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_HasLiveUpdate(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool ret = thisObj->HasLiveUpdate();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_HasLiveUpload(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool ret = thisObj->HasLiveUpload();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_AutoDiscoverable(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool ret = thisObj->AutoDiscoverable();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_IsReplicated(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool ret = thisObj->IsReplicated();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_Trusted(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool ret = thisObj->Trusted();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t IAssetStorage_GetFullAssetURL_String(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    String UNUSED_PARAM = duk_require_string(ctx, 0);
    String ret = thisObj->GetFullAssetURL(UNUSED_PARAM);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t IAssetStorage_Type(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    String ret = thisObj->Type();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t IAssetStorage_Name(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    String ret = thisObj->Name();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t IAssetStorage_BaseURL(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    String ret = thisObj->BaseURL();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t IAssetStorage_ToString(duk_context* ctx)
{
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    String ret = thisObj->ToString();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t IAssetStorage_SerializeToString_bool(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    IAssetStorage* thisObj = GetThisWeakObject<IAssetStorage>(ctx);
    bool networkTransfer = numArgs > 0 ? duk_require_boolean(ctx, 0) : false;
    String ret = thisObj->SerializeToString(networkTransfer);
    duk_push_string(ctx, ret.CString());
    return 1;
}

static const duk_function_list_entry IAssetStorage_Functions[] = {
    {"SetReplicated", IAssetStorage_SetReplicated_bool, 1}
    ,{"GetAllAssetRefs", IAssetStorage_GetAllAssetRefs, 0}
    ,{"RefreshAssetRefs", IAssetStorage_RefreshAssetRefs, 0}
    ,{"Writable", IAssetStorage_Writable, 0}
    ,{"HasLiveUpdate", IAssetStorage_HasLiveUpdate, 0}
    ,{"HasLiveUpload", IAssetStorage_HasLiveUpload, 0}
    ,{"AutoDiscoverable", IAssetStorage_AutoDiscoverable, 0}
    ,{"IsReplicated", IAssetStorage_IsReplicated, 0}
    ,{"Trusted", IAssetStorage_Trusted, 0}
    ,{"GetFullAssetURL", IAssetStorage_GetFullAssetURL_String, 1}
    ,{"Type", IAssetStorage_Type, 0}
    ,{"Name", IAssetStorage_Name, 0}
    ,{"BaseURL", IAssetStorage_BaseURL, 0}
    ,{"ToString", IAssetStorage_ToString, 0}
    ,{"SerializeToString", IAssetStorage_SerializeToString_bool, DUK_VARARGS}
    ,{nullptr, nullptr, 0}
};

void Expose_IAssetStorage(duk_context* ctx)
{
    duk_push_object(ctx);
    duk_push_number(ctx, 0);
    duk_put_prop_string(ctx, -2, "AssetCreate");
    duk_push_number(ctx, 1);
    duk_put_prop_string(ctx, -2, "AssetModify");
    duk_push_number(ctx, 2);
    duk_put_prop_string(ctx, -2, "AssetDelete");
    duk_push_number(ctx, 0);
    duk_put_prop_string(ctx, -2, "StorageUntrusted");
    duk_push_number(ctx, 1);
    duk_put_prop_string(ctx, -2, "StorageTrusted");
    duk_push_number(ctx, 2);
    duk_put_prop_string(ctx, -2, "StorageAskTrust");
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, IAssetStorage_Functions);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, IAssetStorage_ID);
}

}
