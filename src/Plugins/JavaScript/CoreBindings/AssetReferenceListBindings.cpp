// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Asset/AssetReference.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif

#include "Asset/AssetReference.h"


using namespace Tundra;
using namespace std;

namespace JSBindings
{

extern const char* AssetReference_ID;

duk_ret_t AssetReference_Finalizer(duk_context* ctx);

const char* AssetReferenceList_ID = "AssetReferenceList";

duk_ret_t AssetReferenceList_Finalizer(duk_context* ctx)
{
    AssetReferenceList* obj = GetValueObject<AssetReferenceList>(ctx, 0, AssetReferenceList_ID);
    if (obj)
    {
        delete obj;
        SetValueObject(ctx, 0, 0, AssetReferenceList_ID);
    }
    return 0;
}

static duk_ret_t AssetReferenceList_Set_refs(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    AssetReferenceVector refs = GetValueObjectVector<AssetReference>(ctx, 0, AssetReference_ID);
    thisObj->refs = refs;
    return 0;
}

static duk_ret_t AssetReferenceList_Get_refs(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    PushValueObjectVector(ctx, thisObj->refs, AssetReference_ID, AssetReference_Finalizer);
    return 1;
}

static duk_ret_t AssetReferenceList_Set_type(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    String type(duk_require_string(ctx, 0));
    thisObj->type = type;
    return 0;
}

static duk_ret_t AssetReferenceList_Get_type(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    duk_push_string(ctx, thisObj->type.CString());
    return 1;
}

static duk_ret_t AssetReferenceList_Ctor(duk_context* ctx)
{
    AssetReferenceList* newObj = new AssetReferenceList();
    PushConstructorResult<AssetReferenceList>(ctx, newObj, AssetReferenceList_ID, AssetReferenceList_Finalizer);
    return 0;
}

static duk_ret_t AssetReferenceList_Ctor_String(duk_context* ctx)
{
    String preferredType(duk_require_string(ctx, 0));
    AssetReferenceList* newObj = new AssetReferenceList(preferredType);
    PushConstructorResult<AssetReferenceList>(ctx, newObj, AssetReferenceList_ID, AssetReferenceList_Finalizer);
    return 0;
}

static duk_ret_t AssetReferenceList_RemoveLast(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    thisObj->RemoveLast();
    return 0;
}

static duk_ret_t AssetReferenceList_RemoveEmpty(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    thisObj->RemoveEmpty();
    return 0;
}

static duk_ret_t AssetReferenceList_Size(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    uint ret = thisObj->Size();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t AssetReferenceList_Append_AssetReference(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    AssetReference* ref = GetCheckedValueObject<AssetReference>(ctx, 0, AssetReference_ID);
    thisObj->Append(*ref);
    return 0;
}

static duk_ret_t AssetReferenceList_IsEmpty(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    bool ret = thisObj->IsEmpty();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t AssetReferenceList_Set_uint_AssetReference(duk_context* ctx)
{
    AssetReferenceList* thisObj = GetThisValueObject<AssetReferenceList>(ctx, AssetReferenceList_ID);
    uint i = (uint)duk_require_number(ctx, 0);
    AssetReference* ref = GetCheckedValueObject<AssetReference>(ctx, 1, AssetReference_ID);
    thisObj->Set(i, *ref);
    return 0;
}

static duk_ret_t AssetReferenceList_Ctor_Selector(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    if (numArgs == 0)
        return AssetReferenceList_Ctor(ctx);
    if (numArgs == 1 && duk_is_string(ctx, 0))
        return AssetReferenceList_Ctor_String(ctx);
    duk_error(ctx, DUK_ERR_ERROR, "Could not select function overload");
}

static const duk_function_list_entry AssetReferenceList_Functions[] = {
    {"RemoveLast", AssetReferenceList_RemoveLast, 0}
    ,{"RemoveEmpty", AssetReferenceList_RemoveEmpty, 0}
    ,{"Size", AssetReferenceList_Size, 0}
    ,{"Append", AssetReferenceList_Append_AssetReference, 1}
    ,{"IsEmpty", AssetReferenceList_IsEmpty, 0}
    ,{"Set", AssetReferenceList_Set_uint_AssetReference, 2}
    ,{nullptr, nullptr, 0}
};

void Expose_AssetReferenceList(duk_context* ctx)
{
    duk_push_c_function(ctx, AssetReferenceList_Ctor_Selector, DUK_VARARGS);
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, AssetReferenceList_Functions);
    DefineProperty(ctx, "refs", AssetReferenceList_Get_refs, AssetReferenceList_Set_refs);
    DefineProperty(ctx, "type", AssetReferenceList_Get_type, AssetReferenceList_Set_type);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, AssetReferenceList_ID);
}

}
