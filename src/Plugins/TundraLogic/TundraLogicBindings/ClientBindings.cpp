// For conditions of distribution and use, see copyright notice in LICENSE
// This file has been autogenerated with BindingsGenerator

#include "StableHeaders.h"
#include "CoreTypes.h"
#include "JavaScriptInstance.h"
#include "LoggingFunctions.h"
#include "Client.h"

#ifdef _MSC_VER
#pragma warning(disable: 4800)
#endif



using namespace Tundra;
using namespace std;

namespace JSBindings
{



static const char* Client_ID = "Client";

const char* SignalWrapper_Client_AboutToConnect_ID = "SignalWrapper_Client_AboutToConnect";

class SignalWrapper_Client_AboutToConnect
{
public:
    SignalWrapper_Client_AboutToConnect(Object* owner, Signal0< void >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal0< void >* signal_;
};

class SignalReceiver_Client_AboutToConnect : public SignalReceiver
{
public:
    void OnSignal()
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_Client_AboutToConnect_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_Client_AboutToConnect>(ctx, SignalWrapper_Client_AboutToConnect_ID);
    return 0;
}

static duk_ret_t SignalWrapper_Client_AboutToConnect_Connect(duk_context* ctx)
{
    SignalWrapper_Client_AboutToConnect* wrapper = GetThisValueObject<SignalWrapper_Client_AboutToConnect>(ctx, SignalWrapper_Client_AboutToConnect_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_Client_AboutToConnect* receiver = new SignalReceiver_Client_AboutToConnect();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_Client_AboutToConnect::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_Client_AboutToConnect_Disconnect(duk_context* ctx)
{
    SignalWrapper_Client_AboutToConnect* wrapper = GetThisValueObject<SignalWrapper_Client_AboutToConnect>(ctx, SignalWrapper_Client_AboutToConnect_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_Client_AboutToConnect_Emit(duk_context* ctx)
{
    SignalWrapper_Client_AboutToConnect* wrapper = GetThisValueObject<SignalWrapper_Client_AboutToConnect>(ctx, SignalWrapper_Client_AboutToConnect_ID);
    if (!wrapper->owner_) return 0;
    wrapper->signal_->Emit();
    return 0;
}

static duk_ret_t Client_Get_AboutToConnect(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    SignalWrapper_Client_AboutToConnect* wrapper = new SignalWrapper_Client_AboutToConnect(thisObj, &thisObj->AboutToConnect);
    PushValueObject(ctx, wrapper, SignalWrapper_Client_AboutToConnect_ID, SignalWrapper_Client_AboutToConnect_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_Client_AboutToConnect_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_Client_AboutToConnect_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "connect");
    duk_push_c_function(ctx, SignalWrapper_Client_AboutToConnect_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_Client_AboutToConnect_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "disconnect");
    duk_push_c_function(ctx, SignalWrapper_Client_AboutToConnect_Emit, 0);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_Client_Disconnected_ID = "SignalWrapper_Client_Disconnected";

class SignalWrapper_Client_Disconnected
{
public:
    SignalWrapper_Client_Disconnected(Object* owner, Signal0< void >* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal0< void >* signal_;
};

class SignalReceiver_Client_Disconnected : public SignalReceiver
{
public:
    void OnSignal()
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_Client_Disconnected_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_Client_Disconnected>(ctx, SignalWrapper_Client_Disconnected_ID);
    return 0;
}

static duk_ret_t SignalWrapper_Client_Disconnected_Connect(duk_context* ctx)
{
    SignalWrapper_Client_Disconnected* wrapper = GetThisValueObject<SignalWrapper_Client_Disconnected>(ctx, SignalWrapper_Client_Disconnected_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_Client_Disconnected* receiver = new SignalReceiver_Client_Disconnected();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_Client_Disconnected::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_Client_Disconnected_Disconnect(duk_context* ctx)
{
    SignalWrapper_Client_Disconnected* wrapper = GetThisValueObject<SignalWrapper_Client_Disconnected>(ctx, SignalWrapper_Client_Disconnected_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_Client_Disconnected_Emit(duk_context* ctx)
{
    SignalWrapper_Client_Disconnected* wrapper = GetThisValueObject<SignalWrapper_Client_Disconnected>(ctx, SignalWrapper_Client_Disconnected_ID);
    if (!wrapper->owner_) return 0;
    wrapper->signal_->Emit();
    return 0;
}

static duk_ret_t Client_Get_Disconnected(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    SignalWrapper_Client_Disconnected* wrapper = new SignalWrapper_Client_Disconnected(thisObj, &thisObj->Disconnected);
    PushValueObject(ctx, wrapper, SignalWrapper_Client_Disconnected_ID, SignalWrapper_Client_Disconnected_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_Client_Disconnected_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_Client_Disconnected_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "connect");
    duk_push_c_function(ctx, SignalWrapper_Client_Disconnected_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_Client_Disconnected_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "disconnect");
    duk_push_c_function(ctx, SignalWrapper_Client_Disconnected_Emit, 0);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

const char* SignalWrapper_Client_LoginFailed_ID = "SignalWrapper_Client_LoginFailed";

class SignalWrapper_Client_LoginFailed
{
public:
    SignalWrapper_Client_LoginFailed(Object* owner, Signal1< const String &>* signal) :
        owner_(owner),
        signal_(signal)
    {
    }

    WeakPtr<Object> owner_;
    Signal1< const String &>* signal_;
};

class SignalReceiver_Client_LoginFailed : public SignalReceiver
{
public:
    void OnSignal(const String & param0)
    {
        duk_context* ctx = ctx_;
        duk_push_global_object(ctx);
        duk_get_prop_string(ctx, -1, "_OnSignal");
        duk_remove(ctx, -2);
        duk_push_number(ctx, (size_t)key_);
        duk_push_array(ctx);
        duk_push_string(ctx, param0.CString());
        duk_put_prop_index(ctx, -2, 0);
        bool success = duk_pcall(ctx, 2) == 0;
        if (!success) LogError("[JavaScript] OnSignal: " + String(duk_safe_to_string(ctx, -1)));
        duk_pop(ctx);
    }
};

static duk_ret_t SignalWrapper_Client_LoginFailed_Finalizer(duk_context* ctx)
{
    FinalizeValueObject<SignalWrapper_Client_LoginFailed>(ctx, SignalWrapper_Client_LoginFailed_ID);
    return 0;
}

static duk_ret_t SignalWrapper_Client_LoginFailed_Connect(duk_context* ctx)
{
    SignalWrapper_Client_LoginFailed* wrapper = GetThisValueObject<SignalWrapper_Client_LoginFailed>(ctx, SignalWrapper_Client_LoginFailed_ID);
    if (!wrapper->owner_) return 0;
    HashMap<void*, SharedPtr<SignalReceiver> >& signalReceivers = JavaScriptInstance::InstanceFromContext(ctx)->SignalReceivers();
    if (signalReceivers.Find(wrapper->signal_) == signalReceivers.End())
    {
        SignalReceiver_Client_LoginFailed* receiver = new SignalReceiver_Client_LoginFailed();
        receiver->ctx_ = ctx;
        receiver->key_ = wrapper->signal_;
        wrapper->signal_->Connect(receiver, &SignalReceiver_Client_LoginFailed::OnSignal);
        signalReceivers[wrapper->signal_] = receiver;
    }
    CallConnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_Client_LoginFailed_Disconnect(duk_context* ctx)
{
    SignalWrapper_Client_LoginFailed* wrapper = GetThisValueObject<SignalWrapper_Client_LoginFailed>(ctx, SignalWrapper_Client_LoginFailed_ID);
    if (!wrapper->owner_) return 0;
    CallDisconnectSignal(ctx, wrapper->signal_);
    return 0;
}

static duk_ret_t SignalWrapper_Client_LoginFailed_Emit(duk_context* ctx)
{
    SignalWrapper_Client_LoginFailed* wrapper = GetThisValueObject<SignalWrapper_Client_LoginFailed>(ctx, SignalWrapper_Client_LoginFailed_ID);
    if (!wrapper->owner_) return 0;
    String param0 = duk_require_string(ctx, 0);
    wrapper->signal_->Emit(param0);
    return 0;
}

static duk_ret_t Client_Get_LoginFailed(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    SignalWrapper_Client_LoginFailed* wrapper = new SignalWrapper_Client_LoginFailed(thisObj, &thisObj->LoginFailed);
    PushValueObject(ctx, wrapper, SignalWrapper_Client_LoginFailed_ID, SignalWrapper_Client_LoginFailed_Finalizer, false);
    duk_push_c_function(ctx, SignalWrapper_Client_LoginFailed_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Connect");
    duk_push_c_function(ctx, SignalWrapper_Client_LoginFailed_Connect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "connect");
    duk_push_c_function(ctx, SignalWrapper_Client_LoginFailed_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "Disconnect");
    duk_push_c_function(ctx, SignalWrapper_Client_LoginFailed_Disconnect, DUK_VARARGS);
    duk_put_prop_string(ctx, -2, "disconnect");
    duk_push_c_function(ctx, SignalWrapper_Client_LoginFailed_Emit, 1);
    duk_put_prop_string(ctx, -2, "Emit");
    return 1;
}

static duk_ret_t Client_LoginState(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    Client::ClientLoginState ret = thisObj->LoginState();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Client_ConnectionId(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    u32 ret = thisObj->ConnectionId();
    duk_push_number(ctx, ret);
    return 1;
}

static duk_ret_t Client_Login_String_unsigned_short_String_String_String(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    String address = duk_require_string(ctx, 0);
    unsigned short port = (unsigned short)duk_require_number(ctx, 1);
    String username = duk_require_string(ctx, 2);
    String password = duk_require_string(ctx, 3);
    String protocol = numArgs > 4 ? duk_require_string(ctx, 4) : String();
    thisObj->Login(address, port, username, password, protocol);
    return 0;
}

static duk_ret_t Client_Logout(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    thisObj->Logout();
    return 0;
}

static duk_ret_t Client_DoLogout_bool(duk_context* ctx)
{
    int numArgs = duk_get_top(ctx);
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    bool fail = numArgs > 0 ? duk_require_boolean(ctx, 0) : false;
    thisObj->DoLogout(fail);
    return 0;
}

static duk_ret_t Client_IsConnected(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    bool ret = thisObj->IsConnected();
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Client_SetLoginProperty_String_Variant(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    String key = duk_require_string(ctx, 0);
    Variant value = GetVariant(ctx, 1);
    thisObj->SetLoginProperty(key, value);
    return 0;
}

static duk_ret_t Client_LoginProperty_String(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    String key = duk_require_string(ctx, 0);
    Variant ret = thisObj->LoginProperty(key);
    PushVariant(ctx, ret);
    return 1;
}

static duk_ret_t Client_HasLoginProperty_String(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    String key = duk_require_string(ctx, 0);
    bool ret = thisObj->HasLoginProperty(key);
    duk_push_boolean(ctx, ret);
    return 1;
}

static duk_ret_t Client_LoginPropertiesAsXml(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    String ret = thisObj->LoginPropertiesAsXml();
    duk_push_string(ctx, ret.CString());
    return 1;
}

static duk_ret_t Client_ClearLoginProperties(duk_context* ctx)
{
    Client* thisObj = GetThisWeakObject<Client>(ctx);
    thisObj->ClearLoginProperties();
    return 0;
}

static const duk_function_list_entry Client_Functions[] = {
    {"LoginState", Client_LoginState, 0}
    ,{"ConnectionId", Client_ConnectionId, 0}
    ,{"Login", Client_Login_String_unsigned_short_String_String_String, DUK_VARARGS}
    ,{"Logout", Client_Logout, 0}
    ,{"DoLogout", Client_DoLogout_bool, DUK_VARARGS}
    ,{"IsConnected", Client_IsConnected, 0}
    ,{"SetLoginProperty", Client_SetLoginProperty_String_Variant, 2}
    ,{"LoginProperty", Client_LoginProperty_String, 1}
    ,{"HasLoginProperty", Client_HasLoginProperty_String, 1}
    ,{"LoginPropertiesAsXml", Client_LoginPropertiesAsXml, 0}
    ,{"ClearLoginProperties", Client_ClearLoginProperties, 0}
    ,{nullptr, nullptr, 0}
};

void Expose_Client(duk_context* ctx)
{
    duk_push_object(ctx);
    duk_push_number(ctx, 0);
    duk_put_prop_string(ctx, -2, "NotConnected");
    duk_push_number(ctx, 1);
    duk_put_prop_string(ctx, -2, "ConnectionPending");
    duk_push_number(ctx, 2);
    duk_put_prop_string(ctx, -2, "ConnectionEstablished");
    duk_push_number(ctx, 3);
    duk_put_prop_string(ctx, -2, "LoggedIn");
    duk_push_object(ctx);
    duk_put_function_list(ctx, -1, Client_Functions);
    DefineProperty(ctx, "AboutToConnect", Client_Get_AboutToConnect, nullptr);
    DefineProperty(ctx, "Disconnected", Client_Get_Disconnected, nullptr);
    DefineProperty(ctx, "LoginFailed", Client_Get_LoginFailed, nullptr);
    DefineProperty(ctx, "loginState", Client_LoginState, nullptr);
    DefineProperty(ctx, "connectionId", Client_ConnectionId, nullptr);
    DefineProperty(ctx, "connected", Client_IsConnected, nullptr);
    duk_put_prop_string(ctx, -2, "prototype");
    duk_put_global_string(ctx, Client_ID);
}

}
